<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>SDK Development; The Good, The Bad, The Ugly | Javad Arjmandi</title>
<meta name="keywords" content="android, kotlin, sdk, sdk-development, clean-architecture">
<meta name="description" content="Some boring backstory intro
A few years ago, a friend roped me into a &ldquo;simple&rdquo; side project to make some extra cash. The plan? Build a few apps, slap on some ads, and watch the money roll in. Easy, right? Well… not quite. We quickly found ourselves tangled in a mess of issues. Google AdMob gave us trouble, some ad networks were outright shady, and others offered rates so bad, it wasn&rsquo;t even worth the effort. After one particularly frustrating day, it hit me: &ldquo;Why not build a library to handle all these ad networks and decide which ads to show based on the best deal?&rdquo; Little did I know, this concept already had a name - ad mediation. Since we had a few adnetworks to play with, the idea of creating our own SDK seemed like a no-brainer.
To our surprise, the SDK became such a hit (in our scale) that it completely overshadowed the apps we were trying to monetize in the first place. Suddenly, the SDK was the star of the show, and our apps? Well, they took a back seat.
That was the start of my SDK-building journey.
Fast forward through a decade of working with SDKs - both my own and ones from big-name companies and niche B2B partners - and let&rsquo;s just say, I&rsquo;ve seen the good, the bad, and the downright ugly when it comes to SDKs. I think I qualify as a SDK expert.">
<meta name="author" content="Javad Arjmandi">
<link rel="canonical" href="https://arjmandi.de/blog/sdk-dev-good-bad-ugly/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css" integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF&#43;13Dyqob6ASlTrTye8=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://arjmandi.de/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://arjmandi.de/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://arjmandi.de/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://arjmandi.de/apple-touch-icon.png">
<link rel="mask-icon" href="https://arjmandi.de/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://arjmandi.de/blog/sdk-dev-good-bad-ugly/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1K8S7SJRH2"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1K8S7SJRH2');
        }
      </script><meta property="og:url" content="https://arjmandi.de/blog/sdk-dev-good-bad-ugly/">
  <meta property="og:site_name" content="Javad Arjmandi">
  <meta property="og:title" content="SDK Development; The Good, The Bad, The Ugly">
  <meta property="og:description" content="Some boring backstory intro A few years ago, a friend roped me into a “simple” side project to make some extra cash. The plan? Build a few apps, slap on some ads, and watch the money roll in. Easy, right? Well… not quite. We quickly found ourselves tangled in a mess of issues. Google AdMob gave us trouble, some ad networks were outright shady, and others offered rates so bad, it wasn’t even worth the effort. After one particularly frustrating day, it hit me: “Why not build a library to handle all these ad networks and decide which ads to show based on the best deal?” Little did I know, this concept already had a name - ad mediation. Since we had a few adnetworks to play with, the idea of creating our own SDK seemed like a no-brainer. To our surprise, the SDK became such a hit (in our scale) that it completely overshadowed the apps we were trying to monetize in the first place. Suddenly, the SDK was the star of the show, and our apps? Well, they took a back seat. That was the start of my SDK-building journey. Fast forward through a decade of working with SDKs - both my own and ones from big-name companies and niche B2B partners - and let’s just say, I’ve seen the good, the bad, and the downright ugly when it comes to SDKs. I think I qualify as a SDK expert.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="blog">
    <meta property="article:published_time" content="2024-11-21T10:00:00+02:00">
    <meta property="article:modified_time" content="2024-11-21T10:00:00+02:00">
    <meta property="article:tag" content="Android">
    <meta property="article:tag" content="Kotlin">
    <meta property="article:tag" content="Sdk">
    <meta property="article:tag" content="Sdk-Development">
    <meta property="article:tag" content="Clean-Architecture">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SDK Development; The Good, The Bad, The Ugly">
<meta name="twitter:description" content="Some boring backstory intro
A few years ago, a friend roped me into a &ldquo;simple&rdquo; side project to make some extra cash. The plan? Build a few apps, slap on some ads, and watch the money roll in. Easy, right? Well… not quite. We quickly found ourselves tangled in a mess of issues. Google AdMob gave us trouble, some ad networks were outright shady, and others offered rates so bad, it wasn&rsquo;t even worth the effort. After one particularly frustrating day, it hit me: &ldquo;Why not build a library to handle all these ad networks and decide which ads to show based on the best deal?&rdquo; Little did I know, this concept already had a name - ad mediation. Since we had a few adnetworks to play with, the idea of creating our own SDK seemed like a no-brainer.
To our surprise, the SDK became such a hit (in our scale) that it completely overshadowed the apps we were trying to monetize in the first place. Suddenly, the SDK was the star of the show, and our apps? Well, they took a back seat.
That was the start of my SDK-building journey.
Fast forward through a decade of working with SDKs - both my own and ones from big-name companies and niche B2B partners - and let&rsquo;s just say, I&rsquo;ve seen the good, the bad, and the downright ugly when it comes to SDKs. I think I qualify as a SDK expert.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Blogs",
      "item": "https://arjmandi.de/blog/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "SDK Development; The Good, The Bad, The Ugly",
      "item": "https://arjmandi.de/blog/sdk-dev-good-bad-ugly/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "SDK Development; The Good, The Bad, The Ugly",
  "name": "SDK Development; The Good, The Bad, The Ugly",
  "description": "Some boring backstory intro A few years ago, a friend roped me into a \u0026ldquo;simple\u0026rdquo; side project to make some extra cash. The plan? Build a few apps, slap on some ads, and watch the money roll in. Easy, right? Well… not quite. We quickly found ourselves tangled in a mess of issues. Google AdMob gave us trouble, some ad networks were outright shady, and others offered rates so bad, it wasn\u0026rsquo;t even worth the effort. After one particularly frustrating day, it hit me: \u0026ldquo;Why not build a library to handle all these ad networks and decide which ads to show based on the best deal?\u0026rdquo; Little did I know, this concept already had a name - ad mediation. Since we had a few adnetworks to play with, the idea of creating our own SDK seemed like a no-brainer. To our surprise, the SDK became such a hit (in our scale) that it completely overshadowed the apps we were trying to monetize in the first place. Suddenly, the SDK was the star of the show, and our apps? Well, they took a back seat. That was the start of my SDK-building journey. Fast forward through a decade of working with SDKs - both my own and ones from big-name companies and niche B2B partners - and let\u0026rsquo;s just say, I\u0026rsquo;ve seen the good, the bad, and the downright ugly when it comes to SDKs. I think I qualify as a SDK expert.\n",
  "keywords": [
    "android", "kotlin", "sdk", "sdk-development", "clean-architecture"
  ],
  "articleBody": "Some boring backstory intro A few years ago, a friend roped me into a “simple” side project to make some extra cash. The plan? Build a few apps, slap on some ads, and watch the money roll in. Easy, right? Well… not quite. We quickly found ourselves tangled in a mess of issues. Google AdMob gave us trouble, some ad networks were outright shady, and others offered rates so bad, it wasn’t even worth the effort. After one particularly frustrating day, it hit me: “Why not build a library to handle all these ad networks and decide which ads to show based on the best deal?” Little did I know, this concept already had a name - ad mediation. Since we had a few adnetworks to play with, the idea of creating our own SDK seemed like a no-brainer. To our surprise, the SDK became such a hit (in our scale) that it completely overshadowed the apps we were trying to monetize in the first place. Suddenly, the SDK was the star of the show, and our apps? Well, they took a back seat. That was the start of my SDK-building journey. Fast forward through a decade of working with SDKs - both my own and ones from big-name companies and niche B2B partners - and let’s just say, I’ve seen the good, the bad, and the downright ugly when it comes to SDKs. I think I qualify as a SDK expert.\nPart 1: How NOT to develop a SDK (At least targetting the Android platform)? 0. Developing the SDK with a Client-Side Application Mindset Why it’s a bad idea? Sure, building an SDK like it’s just another app sounds tempting. But remember, your SDK is going to live in other people’s apps, all with their own unique setups and preferences. Treating it like a client-side app leads to all kinds of fun issues, like tightly coupled architecture, a complete lack of flexibility, and some deliciously unintended side effects. Client apps come with all kinds of assumptions - about UI, lifecycle, and direct access to device resources - that your SDK has no business messing with. It’s like crashing someone else’s dinner party and rearranging all their furniture.\nI’m not saying you should disregard good practices for client-side apps. It’s equally important for them to have a good, maintainable architecture and remain flexible. However, client-side apps are generally more resilient to faults that would be unacceptable when developing an SDK. Ideally, there shouldn’t even be an option to create technical debt when building an SDK.\nWhat to do instead: Instead of treating your SDK like an app, think of it as a backend service that cannot be updated once live. Decouple your concerns, provide asynchronous operations, and for goodness’ sake, be lightweight and unobtrusive. Your SDK should blend into the background, flexible enough to work across a variety of apps without needing to know how they handle their UI, threading, or device resources. Be the guest that’s never noticed - until they need you.\nExample: “I Control the UI Now, Mwahaha!”\nclass Sdk { fun showProgressDialog(context: Context) { // Let's hijack the UI without asking! ProgressDialog(context).apply { setTitle(\"Please wait...\") setMessage(\"SDK is doing something super important!\") show() } } } Because who doesn’t want their UI randomly hijacked by some SDK? You’ve spent hours perfecting your app’s UX, but sure, let’s just throw in this uninvited ProgressDialog in the middle of everything. Thanks, SDK!\nGood Practice: “Wait, SDKs Shouldn’t Mess With UIs?”\nclass Sdk { fun performBackendOperation(callback: (Result\u003cString\u003e) -\u003e Unit) { // Asynchronous backend logic without UI intervention callback(Result.success(\"Operation Completed!\")) } } Look, mom, no UI! The SDK does what it’s supposed to: backend operations, leaving the app developer to decide how to show progress, if at all.\nWait, what if the UI is part of what our SDK is trying to offer?\nYou’re already going to ruin the experience of the poor developer trying to integrate your SDK into their app. You might think:\nBut the end user will have a good experience\nAnd while that might be true in some cases, it’s often unlikely for various reasons, including:\nLack of Flexibility for Developers: Predefined UI components limit developers’ ability to customize the user interface, making it difficult to align the SDK’s UI with the app’s branding and design. Since the UI is fixed, integrators also lose the ability to embed custom analytics, making it harder to track user activity for marketing or product analysis. This leads to inconsistent user experiences and missed insights, negatively impacting the perception of both the app and the SDK. Resource Conflicts: Bundling UI components can cause resource naming collisions (e.g., IDs, styles, or themes) between the SDK and the host app, leading to unexpected crashes or visual inconsistencies. These issues can require significant debugging effort, reducing developers’ trust in the SDK. Increased Maintenance Complexity: Including UI in the SDK requires ongoing maintenance to ensure compatibility with various Android versions, devices, and design guidelines. This increases the maintenance burden, and delays or unaddressed issues can frustrate developers and users, making the SDK less appealing. Larger SDK Size: Shipping UI components increases the overall size of the SDK, which contributes to larger app sizes. This can deter developers from adopting the SDK, and end-users may avoid downloading apps or uninstall them due to size concerns, indirectly affecting SDK adoption. (like yeah, let’s integrate “com.github.javad:awesome-animation:0.0.2” and add 5 more megabytes to poor developer’s app) Limited Reusability and Scalability: UI components shipped with the SDK are often not reusable or scalable across different projects. Developers working on apps with custom flows or designs may need to bypass or rewrite the SDK’s UI. Additionally, because the UI is fixed, integrators cannot track user activity within the SDK for custom marketing or product analytics purposes, reducing its value and making it appear rigid and developer-unfriendly. If you absolutely have to ship UI as part of your project, the best way to approach it is to make the UI optional and modular. Here’s how you can do it:\nSeparate UI and Core Logic: Create two distinct packages: one for the core functionality and one for the UI components. This allows developers to choose whether they want to use the provided UI or build their own while still leveraging the core logic of the SDK. Provide Clear Documentation: Offer detailed instructions for implementing the SDK with and without the built-in UI. Include code samples and guidelines for developers who want to customize or replace the default UI. Make the UI Customizable: If you include a UI package, ensure it is fully customizable. Allow developers to override styles, colors, fonts, and even layouts to match their app’s branding and design. Design for Integration: Ensure the UI components follow Android’s Material Design guidelines and can adapt seamlessly to different themes, orientations, and screen sizes. Use isolated namespaces to avoid resource conflicts. Support Analytics Hooks: Provide APIs or callbacks that allow developers to integrate their analytics and tracking solutions into the SDK’s UI. This ensures that they can still collect data and maintain insights into user behavior. Offer a “Headless Mode”: For advanced users, offer a “headless” mode that exposes only the core logic, enabling developers to integrate it into their own UI without relying on your SDK’s visuals. An ideal SDK with UI should have at least 2 importable modules, 1 for the core functionality, and one for UI.\n1. Using 3rd Party Libraries Inside Your SDK Why it’s a bad idea? Sure, nothing says “I’m in a hurry” like cramming in every shiny third-party library you can find. But here’s the catch: it comes with a whole list of issues. Ever dealt with version conflicts? Yeah, enjoy those. Licensing problems? Even better! Or how about making the host app developers manage complex dependency resolution because your SDK decided to use a different version of Retrofit, OkHttp, Glide, and Lottie than they do? Just imagine the joy when their app breaks, and they have to dig through Maven hell to figure out which library caused the explosion. You’re welcome!\nWhat to do instead: Minimize external dependencies like you’re on a code diet. Especially for core functionality. If you absolutely must drag in third-party libraries (and hey, I get it, they’re useful), isolate them. Or better yet, give the app developers the option to exclude or replace them. And please, document what libraries you’re using so it doesn’t feel like a game of “surprise dependency roulette.” It’s a party no one wants to attend.\nExample: “Let’s Bring the Whole Party! Retrofit, OkHttp, Glide, and Lottie!”\nclass Sdk { // Retrofit to fetch data private val retrofit = Retrofit.Builder() .baseUrl(\"https://api.example.com/\") .build() // OkHttp for all the fancy HTTP interceptors private val client = OkHttpClient.Builder().build() // Glide to load images, of course fun loadImage(context: Context, imageUrl: String, imageView: ImageView) { Glide.with(context) .load(imageUrl) .into(imageView) } // And why not add Lottie animations for good measure? fun showLottieAnimation(context: Context, animationView: LottieAnimationView) { animationView.setAnimation(\"cool_animation.json\") animationView.playAnimation() } } Because why just load ads when you can load the entire internet along with them? Let’s add Retrofit for fetching some unnecessary data, OkHttp for all those fancy interceptors, Glide to load the most important image in history, and hey, let’s slap a Lottie animation on it too. What could go wrong? 🤷‍♂️ I mean, who doesn’t love an SDK that bloats your app by 10MB with libraries it never even needed? Oh, and good luck dealing with version conflicts in your app! 😎 Good Practice: Just Keep It Simple, Stupid\nclass Sdk { // Avoid unnecessary dependencies fun performSimpleNetworkOperation(callback: (Result\u003cString\u003e) -\u003e Unit) { // Use plain old URL and HttpURLConnection, or let the app manage HTTP libraries. callback(Result.success(\"Fetched data\")) } // Let the app handle image loading and animations fun loadDataAndReturnUrl(callback: (String) -\u003e Unit) { // Just return a URL and let the app handle loading the image or animation callback(\"https://image.example.com\") } } Here’s an idea: let the developer decide if they want to use Retrofit, OkHttp, Glide, or Lottie. Stop packing your SDK like it’s the IKEA of dependencies. Simplicity wins the day.\n1.1 Using Deprecated Libraries Why it’s a bad idea? (as if them being a 3rd party is not bad enough) Ah, deprecated libraries - like old, broken toys that should’ve been thrown out years ago, but somehow you just can’t let go. They no longer receive updates, bug fixes, or any kind of love. In fact, they bring along security vulnerabilities and compatibility issues like unwanted party crashers. If your SDK relies on them, congratulations: you’ve just created a ticking time bomb for your users’ apps.\nWhat to do instead: Keep up with the times. Refactor your SDK and ditch deprecated libraries before they sink the ship. Continuously monitor the libraries you’re using (yes, that means some extra work) and update them before they’re completely irrelevant - or worse, break something critical. Your users will thank you for not making them fight with zombie dependencies.\nExample: “AsyncTask is My Best Friend”\nclass Sdk { fun fetchDataInBackground() { // Who cares if AsyncTask is deprecated? It's a classic! object : AsyncTask\u003cVoid, Void, String\u003e() { override fun doInBackground(vararg params: Void?): String { // Simulating a network call return \"Data fetched from background\" } override fun onPostExecute(result: String?) { // Handle result on the main thread } }.execute() } } Because who cares about Kotlin coroutines when we can use trusty old AsyncTask that Google has been telling us to avoid for years? Let’s keep that 2012 vibe going strong. (And yes, I first hand found someone use it in 2024)\nGood Practice: “Welcome to the 2020s - We Have Coroutines Now”\nclass Sdk { fun fetchDataInBackground(callback: (Result\u003cString\u003e) -\u003e Unit) { GlobalScope.launch(Dispatchers.IO) { try { val data = \"Fetched data\" withContext(Dispatchers.Main) { callback(Result.success(data)) } } catch (e: Exception) { withContext(Dispatchers.Main) { callback(Result.failure(e)) } } } } } Ah, Kotlin Coroutines, the cool, modern way to handle background tasks without dragging apps back to the dark ages. The best part? They don’t trigger ANRs and actually make you look like you know what you’re doing. I’m not ranting about coroutines. I’m talking about those libraries buried six feet under in the graveyard of GitHub, last updated in 2019. Found some old but “reliable” library that’s no longer maintained? Great, now definitely don’t use its sketchy forks in an SDK you’re shipping for poor developers to suffer through. Always remember: if the original library was abandoned, there’s probably a good reason for it. Do everyone a favor and find a modern replacement instead.\n2. Using Singletons and Global State Management Why It’s a Bad Idea: Ah yes, singletons - easy to set up, but a nightmare to live with when combined with mutable global state. They introduce unpredictable behavior, especially in multi-threaded environments, leading to race conditions, inconsistent states, and debugging nightmares. Need more than one instance of your SDK in the same app? Good luck with that. Worse, singletons often cause memory leaks by holding references to contexts or activities. They also hide dependencies, making code harder to test, maintain, and extend. Simply put, global state is a global headache.\nWhat to Do Instead: Use dependency injection or factory patterns to create and manage your SDK instances. This gives the client app control over the scope and lifecycle of your SDK components, ensuring predictable behavior. Avoid mutable global state - keep state context-aware and scoped to instances. If you need shared functionality, consider context-safe singletons with immutable state or thread-safe designs. And always design your SDK to support multiple instances where applicable. Responsible scoping leads to cleaner code and fewer headaches.\nExample: “Global State, Global Headache”\nobject SdkSingleton { var globalAdState: String = \"No ad loaded yet\" fun loadAd() { // Modify global state at will! globalAdState = \"Ad loaded!\" } } Good Practice: “Let’s Scope This Like Adults”\nclass Sdk(private var adState: String) { fun loadAd(): Sdk { // Create a new instance with updated state return Sdk(\"Ad loaded!\") } } // Create new instances without messing with global state val sdkInstance = Sdk(\"No ad loaded\") val newSdkInstance = sdkInstance.loadAd() Keep your global state to yourself, thank you. Scoping state to instances like a responsible developer means fewer headaches and less chaos.\n3. Poor Documentation Why it’s a bad idea? So, you’ve built an amazing SDK, but forgot to tell anyone how to actually use it. Now developers are banging their heads against the wall trying to figure out what your methods do. Misuse, bugs, and frustrated support emails follow. But hey, it’s their fault for not reading your mind, right?\nWhat to do instead: Write documentation like you’re being graded on it. Clear, concise, and, most importantly, up-to-date. Include everything developers need: installation instructions, detailed API references, code examples, common use cases, and troubleshooting guides. And remember, just like your SDK, your docs should evolve. Developers don’t have time for guesswork; help them out!\nExample: “Good Luck, You’ll Need It”\nclass Sdk { fun doSomethingSuperImportant() { // But I won't tell you how or why } } Good Practice: “Let’s Be Nice - Write Documentation”\n/** * Performs an important task that retrieves user data. * * @param userId ID of the user to fetch data for. * @return User data in a Result wrapper. */ class Sdk { fun fetchUserData(userId: String, callback: (Result\u003cString\u003e) -\u003e Unit) { // Retrieves user data and passes it to the callback callback(Result.success(\"User data for $userId\")) } } Imagine the joy on a developer’s face when they actually understand how your SDK works! Clear documentation is like a ray of sunshine on a cloudy day.\n4. Bad Communication of Changes Why it’s a bad idea? Making breaking changes without telling anyone is the ultimate plot twist. You’ll leave developers scratching their heads when their app mysteriously starts crashing after your latest update. And when features disappear or behaviors change with no explanation? Well, you’ve just created a new level of frustration. Bonus points if the developer only finds out after deploying their app to production! What to do instead: Communicate like an adult. Use proper versioning (ever heard of semantic versioning? It’s your friend). Maintain a changelog that’s actually useful, marking breaking changes clearly, and providing migration guides. Offering beta releases to let developers adapt before the official update drops? Now that’s next-level professional.\n5. Heavy-loading and Big Size of the AAR Why it’s a bad idea? Your SDK should be lean and mean, but instead, it’s bloated like a post-buffet nap. A large SDK increases app size, leading to longer build times, sluggish performance, and higher memory usage. You’ve just transformed that sleek app into a lumbering dinosaur. End users now get to enjoy painfully slow downloads, and developers get to spend their days trying to optimize around your behemoth of an SDK.\nWhat to do instead: Trim the fat. Optimize your SDK by stripping unused code and resources. Use ProGuard or R8 to shrink and obfuscate code, and modularize your SDK so developers can choose only the parts they need. The goal? A lightweight core with optional feature modules. Because no one likes dragging around unnecessary baggage.\nExample: “Let’s Make This AAR the Size of a Small Planet”\n// Packed with unnecessary resources like high-res images and massive JSON files res/drawable/hd_background.png res/animations/full_length_animation.json asset/mother_nature.so Good Practice: “Let’s Not Make Developers Hate Us”\n// Use ProGuard to slim down the AAR android { buildTypes { release { minifyEnabled true proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro' } } } // Split into modules so developers can choose what they actually need implementation(\"com.example.sdk:core:1.0.0\") implementation(\"com.example.sdk:ad-module:1.0.0\") Part 2: An Ideal approach 1. SDKs Are Modules in Disguise The process of developing an SDK closely resembles that of designing a module in a modular architecture, and adhering to clean architecture principles isn’t just “nice to have” - it’s essential. An SDK must behave like a guest in someone else’s app, blending seamlessly without imposing on the host app’s architecture. Let’s break this down technically:\n1. Decoupling Concerns:\nClean architecture separates business logic (what the SDK does) from implementation details (how it does it). For example, the SDK should expose its core functionality via interfaces or abstract classes, while internal implementations remain private and modularized. This ensures the SDK is flexible and doesn’t directly tie its implementation to specific frameworks or third-party libraries. interface AdLoader { fun loadAd(callback: (Result\u003cString\u003e) -\u003e Unit) } class AdLoaderImpl(private val networkClient: NetworkClient) : AdLoader { override fun loadAd(callback: (Result\u003cString\u003e) -\u003e Unit) { networkClient.fetchAd { result -\u003e callback(result) } } } Here, AdLoader abstracts the business logic of loading ads, while AdLoaderImpl provides the implementation. The app integrating the SDK only interacts with the interface, keeping things modular and easy to test.\n2. Testability:\nClean architecture ensures your SDK’s core logic is independent of Android-specific APIs, making it easier to test. For instance, avoid tying core logic to Activity, Context, or ViewModel classes. Instead, inject platform-dependent dependencies where needed, keeping the core business logic free from platform concerns. 3. Scalability:\nModular SDKs are easier to maintain and scale. If you decide to add a new feature (e.g., analytics integration), you can do so without overhauling the existing code. Separate the analytics feature into a module, and expose it only to apps that choose to include it. How to Apply Clean Architecture to SDKs 1. Domain Layer: Handles the business rules and logic of your SDK. Expose only what’s necessary through interfaces and keep this layer entirely independent of third-party libraries or platform code.\n2. Data Layer: Manages data sources (e.g., network or local storage). Use repository patterns to abstract data operations.\n3. Interface Layer (Optional): If your SDK includes UI, provide it as an optional package, separate from the core SDK logic. Use Compose or Views but allow developers to customize it or bypass it entirely.\n4. Dependency Injection: Design your SDK to work with DI frameworks like Dagger, Koin, or Hilt, or provide a way to inject dependencies manually. This gives integrators full control over lifecycle and scoping.\nKey Takeaway: Clean architecture makes your SDK predictable, maintainable, and easy to integrate. Developers can trust that it will not clash with their app’s architecture or create unwanted dependencies.\nAnd I might not be the best person for teaching clean architecture. There are more than enough resources out there that you can learn from. The “Clean Architecture: A Craftsman’s Guide to Software Structure and Design” by uncle bob is the perfect resource.\nSwallow the Hard Pill of Library Implementation SDK development requires a different mindset compared to app development, particularly when it comes to handling dependencies. Relying on third-party libraries in your SDK can lead to dependency hell for developers integrating it into their apps. Here’s a deeper dive into why and how to handle this challenge:\nWhy Overusing Third-Party Libraries is Problematic 1. Version Conflicts: Apps integrating your SDK may already use the same libraries (e.g., Retrofit, OkHttp, Glide) but with different versions. If your SDK forces its version of these libraries, it can lead to dependency clashes that break the app. For example The host app uses Retrofit 2.9.0, but your SDK is built with Retrofit 2.5.0. The app fails to compile because Gradle doesn’t know which version to use. Even if it compiles, runtime crashes could occur due to API differences.\n2. Increased APK Size: Every third-party library you include adds weight to the SDK. For instance, Glide adds several MBs of resources and code, which might not even be used if the app already has its own image-loading library, bloating the integrator’s app.\n3. Licensing Issues: Not all libraries are compatible with commercial or open-source SDKs. Using a library with a restrictive license (e.g., GPL) can expose your SDK and its users to legal risks. Just because a project or developer hasn’t sued you yet, doesn’t mean what you’re doing is legal.\nHow to Avoid These Pitfalls 1. Implement Features Yourself: Yeah yeah “Don’t reinvent the wheel” and all, but we have the above problems to address, rememeber? Instead of relying on libraries for common tasks, consider implementing lightweight, custom solutions tailored to your SDK’s needs.\nExample: For networking, instead of using Retrofit:\nfun fetchAd(callback: (Result\u003cString\u003e) -\u003e Unit) { val url = URL(\"https://api.example.com/ads\") val connection = url.openConnection() as HttpURLConnection try { val data = connection.inputStream.bufferedReader().readText() callback(Result.success(data)) } catch (e: Exception) { callback(Result.failure(e)) } finally { connection.disconnect() } } This implementation avoids dragging in a large library and keeps your SDK lightweight.\n2. Isolate Dependencies: If a library is unavoidable, wrap it in an abstraction layer so the host app doesn’t interact with it directly. This also makes it easier to replace the library in the future without breaking the SDK’s API.\nExample:\ninterface ImageLoader { fun loadImage(url: String, imageView: ImageView) } class GlideImageLoader : ImageLoader { override fun loadImage(url: String, imageView: ImageView) { Glide.with(imageView.context).load(url).into(imageView) } } Again, do this as a last resort. It’s always better to have your own implementation of essential libraries for networking, asynchronous operations, etc.\n3. Make Dependencies Optional: Use Gradle’s optional dependencies to allow developers to exclude libraries they don’t need.\nimplementation(\"com.example.sdk:core:1.0.0\") implementation(\"com.example.sdk:ui:1.0.0\") // Include only if UI is needed Does your SDK provides more than 1 functionality? Then chances are you’re gonna need a package per functionality. A very perfect and relatable example is how Firebase has designed its dependencies with its Android SDK.\nKey Takeaway: By implementing features in-house and isolating dependencies, you ensure your SDK is lightweight, conflict-free, and safe to integrate. Yes, it’s more work upfront, but it’s worth it to avoid becoming the SDK developers hate using.\nConclusion: Developing an SDK is not just about building functionality; it’s about crafting a developer-friendly experience that integrates seamlessly into diverse apps without causing headaches. As this article has outlined, creating an effective SDK requires careful consideration of architecture, dependencies, UI integration, and communication with developers. It’s a balancing act between providing robust functionality and maintaining flexibility, scalability, and simplicity.\nBy treating your SDK as a modular system adhering to clean architecture principles, you ensure maintainability, testability, and long-term compatibility. Writing your own libraries, while a harder path, avoids the pitfalls of third-party dependency conflicts, licensing issues, and bloated SDK sizes, making your SDK a lightweight, reliable addition to any app.\nUltimately, an SDK is a tool meant to empower developers, not frustrate them. Keep your design unobtrusive, your APIs intuitive, and your documentation thorough. If you approach SDK development with the same care you would a mission-critical backend service, you’ll create a product that developers trust and love to use.\nSDK development may be challenging, but by applying these principles, you can turn the good, the bad, and the ugly into a toolkit that stands out in the best way possible. Remember, when developers integrate your SDK, they’re placing their trust in you - don’t let them down.\n",
  "wordCount" : "4129",
  "inLanguage": "en",
  "datePublished": "2024-11-21T10:00:00+02:00",
  "dateModified": "2024-11-21T10:00:00+02:00",
  "author":{
    "@type": "Person",
    "name": "Javad Arjmandi"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://arjmandi.de/blog/sdk-dev-good-bad-ugly/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Javad Arjmandi",
    "logo": {
      "@type": "ImageObject",
      "url": "https://arjmandi.de/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://arjmandi.de/" accesskey="h" title="Javad Arjmandi (Alt + H)">Javad Arjmandi</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://arjmandi.de/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://arjmandi.de/blog/" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      SDK Development; The Good, The Bad, The Ugly
    </h1>
    <div class="post-meta"><span title='2024-11-21 10:00:00 +0200 +0200'>November 21, 2024</span>&nbsp;·&nbsp;20 min&nbsp;·&nbsp;Javad Arjmandi

</div>
  </header> 
  <div class="post-content"><h2 id="some-boring-backstory-intro">Some boring backstory intro<a hidden class="anchor" aria-hidden="true" href="#some-boring-backstory-intro">#</a></h2>
<p>A few years ago, a friend roped me into a &ldquo;simple&rdquo; side project to make some extra cash. The plan? Build a few apps, slap on some ads, and watch the money roll in. Easy, right? Well… not quite. We quickly found ourselves tangled in a mess of issues. Google AdMob gave us trouble, some ad networks were outright shady, and others offered rates so bad, it wasn&rsquo;t even worth the effort. After one particularly frustrating day, it hit me: &ldquo;Why not build a library to handle all these ad networks and decide which ads to show based on the best deal?&rdquo; Little did I know, this concept already had a name - ad mediation. Since we had a few adnetworks to play with, the idea of creating our own SDK seemed like a no-brainer.
To our surprise, the SDK became such a hit (in our scale) that it completely overshadowed the apps we were trying to monetize in the first place. Suddenly, the SDK was the star of the show, and our apps? Well, they took a back seat.
That was the start of my SDK-building journey.
Fast forward through a decade of working with SDKs - both my own and ones from big-name companies and niche B2B partners - and let&rsquo;s just say, I&rsquo;ve seen the good, the bad, and the downright ugly when it comes to SDKs. I think I qualify as a SDK expert.</p>
<h2 id="part-1-how-not-to-develop-a-sdk-at-least-targetting-the-android-platform">Part 1: How NOT to develop a SDK (At least targetting the Android platform)?<a hidden class="anchor" aria-hidden="true" href="#part-1-how-not-to-develop-a-sdk-at-least-targetting-the-android-platform">#</a></h2>
<h3 id="0-developing-the-sdk-with-a-client-side-application-mindset">0. Developing the SDK with a Client-Side Application Mindset<a hidden class="anchor" aria-hidden="true" href="#0-developing-the-sdk-with-a-client-side-application-mindset">#</a></h3>
<p><strong>Why it&rsquo;s a bad idea?</strong>
Sure, building an SDK like it&rsquo;s just another app sounds tempting. But remember, your SDK is going to live in other people&rsquo;s apps, all with their own unique setups and preferences. Treating it like a client-side app leads to all kinds of fun issues, like tightly coupled architecture, a complete lack of flexibility, and some deliciously unintended side effects. Client apps come with all kinds of assumptions - about UI, lifecycle, and direct access to device resources - that your SDK has no business messing with. It&rsquo;s like crashing someone else&rsquo;s dinner party and rearranging all their furniture.</p>
<p>I&rsquo;m not saying you should disregard good practices for client-side apps. It&rsquo;s equally important for them to have a good, maintainable architecture and remain flexible. However, client-side apps are generally more resilient to faults that would be unacceptable when developing an SDK. Ideally, there shouldn&rsquo;t even be an option to create technical debt when building an SDK.</p>
<p><strong>What to do instead:</strong>
Instead of treating your SDK like an app, think of it as a backend service that cannot be updated once live. Decouple your concerns, provide asynchronous operations, and for goodness&rsquo; sake, be lightweight and unobtrusive. Your SDK should blend into the background, flexible enough to work across a variety of apps without needing to know how they handle their UI, threading, or device resources. Be the guest that&rsquo;s never noticed - until they need you.</p>
<p><strong>Example</strong>: &ldquo;I Control the UI Now, Mwahaha!&rdquo;</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Sdk</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">fun</span> <span class="nf">showProgressDialog</span><span class="p">(</span><span class="n">context</span><span class="p">:</span> <span class="n">Context</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Let&#39;s hijack the UI without asking!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">ProgressDialog</span><span class="p">(</span><span class="n">context</span><span class="p">).</span><span class="n">apply</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">setTitle</span><span class="p">(</span><span class="s2">&#34;Please wait...&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">setMessage</span><span class="p">(</span><span class="s2">&#34;SDK is doing something super important!&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">show</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Because who doesn&rsquo;t want their UI randomly hijacked by some SDK? You&rsquo;ve spent hours perfecting your app&rsquo;s UX, but sure, let&rsquo;s just throw in this uninvited <code>ProgressDialog</code> in the middle of everything. Thanks, SDK!</p>
<p><strong>Good Practice</strong>: &ldquo;Wait, SDKs Shouldn&rsquo;t Mess With UIs?&rdquo;</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Sdk</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">fun</span> <span class="nf">performBackendOperation</span><span class="p">(</span><span class="n">callback</span><span class="p">:</span> <span class="p">(</span><span class="n">Result</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="o">-&gt;</span> <span class="n">Unit</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Asynchronous backend logic without UI intervention
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">callback</span><span class="p">(</span><span class="nc">Result</span><span class="p">.</span><span class="n">success</span><span class="p">(</span><span class="s2">&#34;Operation Completed!&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Look, mom, no UI! The SDK does what it&rsquo;s supposed to: backend operations, leaving the app developer to decide how to show progress, if at all.</p>
<blockquote>
<p>Wait, what if the UI is part of what our SDK is trying to offer?</p></blockquote>
<p>You&rsquo;re already going to ruin the experience of the poor developer trying to integrate your SDK into their app. You might think:</p>
<blockquote>
<p>But the end user will have a good experience</p></blockquote>
<p>And while that might be true in some cases, it&rsquo;s often unlikely for various reasons, including:</p>
<ol>
<li><strong>Lack of Flexibility for Developers:</strong> Predefined UI components limit developers&rsquo; ability to customize the user interface, making it difficult to align the SDK&rsquo;s UI with the app&rsquo;s branding and design. Since the UI is fixed, integrators also lose the ability to embed custom analytics, making it harder to track user activity for marketing or product analysis. This leads to inconsistent user experiences and missed insights, negatively impacting the perception of both the app and the SDK.</li>
<li><strong>Resource Conflicts</strong>: Bundling UI components can cause resource naming collisions (e.g., IDs, styles, or themes) between the SDK and the host app, leading to unexpected crashes or visual inconsistencies. These issues can require significant debugging effort, reducing developers&rsquo; trust in the SDK.</li>
<li><strong>Increased Maintenance Complexity</strong>: Including UI in the SDK requires ongoing maintenance to ensure compatibility with various Android versions, devices, and design guidelines. This increases the maintenance burden, and delays or unaddressed issues can frustrate developers and users, making the SDK less appealing.</li>
<li><strong>Larger SDK Size</strong>: Shipping UI components increases the overall size of the SDK, which contributes to larger app sizes. This can deter developers from adopting the SDK, and end-users may avoid downloading apps or uninstall them due to size concerns, indirectly affecting SDK adoption. (like yeah, let&rsquo;s integrate &ldquo;com.github.javad:awesome-animation:0.0.2&rdquo; and add 5 more megabytes to poor developer&rsquo;s app)</li>
<li><strong>Limited Reusability and Scalability</strong>: UI components shipped with the SDK are often not reusable or scalable across different projects. Developers working on apps with custom flows or designs may need to bypass or rewrite the SDK&rsquo;s UI. Additionally, because the UI is fixed, integrators cannot track user activity within the SDK for custom marketing or product analytics purposes, reducing its value and making it appear rigid and developer-unfriendly.</li>
</ol>
<p>If you <em><strong>absolutely have to</strong></em> ship UI as part of your project, the best way to approach it is to <strong>make the UI optional and modular</strong>. Here&rsquo;s how you can do it:</p>
<ol>
<li><strong>Separate UI and Core Logic:</strong> Create two distinct packages: one for the core functionality and one for the UI components. This allows developers to choose whether they want to use the provided UI or build their own while still leveraging the core logic of the SDK.</li>
<li><strong>Provide Clear Documentation:</strong> Offer detailed instructions for implementing the SDK with and without the built-in UI. Include code samples and guidelines for developers who want to customize or replace the default UI.</li>
<li><strong>Make the UI Customizable:</strong> If you include a UI package, ensure it is fully customizable. Allow developers to override styles, colors, fonts, and even layouts to match their app&rsquo;s branding and design.</li>
<li><strong>Design for Integration:</strong> Ensure the UI components follow Android&rsquo;s Material Design guidelines and can adapt seamlessly to different themes, orientations, and screen sizes. Use isolated namespaces to avoid resource conflicts.</li>
<li><strong>Support Analytics Hooks:</strong> Provide APIs or callbacks that allow developers to integrate their analytics and tracking solutions into the SDK&rsquo;s UI. This ensures that they can still collect data and maintain insights into user behavior.
<strong>Offer a &ldquo;Headless Mode&rdquo;:</strong> For advanced users, offer a &ldquo;headless&rdquo; mode that exposes only the core logic, enabling developers to integrate it into their own UI without relying on your SDK&rsquo;s visuals.</li>
</ol>
<p>An ideal SDK with UI should have at least 2 importable modules, 1 for the core functionality, and one for UI.</p>
<h3 id="1-using-3rd-party-libraries-inside-yoursdk">1. Using 3rd Party Libraries Inside Your SDK<a hidden class="anchor" aria-hidden="true" href="#1-using-3rd-party-libraries-inside-yoursdk">#</a></h3>
<p><strong>Why it&rsquo;s a bad idea?</strong>
Sure, nothing says &ldquo;I&rsquo;m in a hurry&rdquo; like cramming in every shiny third-party library you can find. But here&rsquo;s the catch: it comes with a whole list of issues. Ever dealt with version conflicts? Yeah, enjoy those. Licensing problems? Even better! Or how about making the host app developers manage complex dependency resolution because your SDK decided to use a different version of Retrofit, OkHttp, Glide, and Lottie than they do? Just imagine the joy when their app breaks, and they have to dig through Maven hell to figure out which library caused the explosion. You&rsquo;re welcome!</p>
<p><strong>What to do instead:</strong>
Minimize external dependencies like you&rsquo;re on a code diet. Especially for core functionality. If you absolutely must drag in third-party libraries (and hey, I get it, they&rsquo;re useful), isolate them. Or better yet, give the app developers the option to exclude or replace them. And please, document what libraries you&rsquo;re using so it doesn&rsquo;t feel like a game of &ldquo;surprise dependency roulette.&rdquo; It&rsquo;s a party no one wants to attend.</p>
<p><strong>Example</strong>: &ldquo;Let&rsquo;s Bring the Whole Party! Retrofit, OkHttp, Glide, and Lottie!&rdquo;</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Sdk</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Retrofit to fetch data
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">private</span> <span class="k">val</span> <span class="py">retrofit</span> <span class="p">=</span> <span class="nc">Retrofit</span><span class="p">.</span><span class="n">Builder</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">baseUrl</span><span class="p">(</span><span class="s2">&#34;https://api.example.com/&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">build</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// OkHttp for all the fancy HTTP interceptors
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">private</span> <span class="k">val</span> <span class="py">client</span> <span class="p">=</span> <span class="nc">OkHttpClient</span><span class="p">.</span><span class="n">Builder</span><span class="p">().</span><span class="n">build</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Glide to load images, of course
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">fun</span> <span class="nf">loadImage</span><span class="p">(</span><span class="n">context</span><span class="p">:</span> <span class="n">Context</span><span class="p">,</span> <span class="n">imageUrl</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="n">imageView</span><span class="p">:</span> <span class="n">ImageView</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nc">Glide</span><span class="p">.</span><span class="n">with</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">imageUrl</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">.</span><span class="n">into</span><span class="p">(</span><span class="n">imageView</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// And why not add Lottie animations for good measure?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">fun</span> <span class="nf">showLottieAnimation</span><span class="p">(</span><span class="n">context</span><span class="p">:</span> <span class="n">Context</span><span class="p">,</span> <span class="n">animationView</span><span class="p">:</span> <span class="n">LottieAnimationView</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">animationView</span><span class="p">.</span><span class="n">setAnimation</span><span class="p">(</span><span class="s2">&#34;cool_animation.json&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">animationView</span><span class="p">.</span><span class="n">playAnimation</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>Because why just load ads when you can load the entire internet along with them? Let&rsquo;s add <strong>Retrofit</strong> for fetching some unnecessary data, <strong>OkHttp</strong> for all those fancy interceptors, <strong>Glide</strong> to load the most important image in history, and hey, let&rsquo;s slap a <strong>Lottie</strong> animation on it too. What could go wrong? 🤷‍♂️</li>
<li>I mean, who doesn&rsquo;t love an SDK that bloats your app by 10MB with libraries it never even needed? Oh, and good luck dealing with version conflicts in your app! 😎</li>
</ul>
<p><strong>Good Practice:</strong> Just Keep It Simple, Stupid</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Sdk</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Avoid unnecessary dependencies
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">fun</span> <span class="nf">performSimpleNetworkOperation</span><span class="p">(</span><span class="n">callback</span><span class="p">:</span> <span class="p">(</span><span class="n">Result</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="o">-&gt;</span> <span class="n">Unit</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Use plain old URL and HttpURLConnection, or let the app manage HTTP libraries.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">callback</span><span class="p">(</span><span class="nc">Result</span><span class="p">.</span><span class="n">success</span><span class="p">(</span><span class="s2">&#34;Fetched data&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Let the app handle image loading and animations
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">fun</span> <span class="nf">loadDataAndReturnUrl</span><span class="p">(</span><span class="n">callback</span><span class="p">:</span> <span class="p">(</span><span class="n">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Unit</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Just return a URL and let the app handle loading the image or animation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">callback</span><span class="p">(</span><span class="s2">&#34;https://image.example.com&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Here&rsquo;s an idea: let the <strong>developer</strong> decide if they want to use Retrofit, OkHttp, Glide, or Lottie. Stop packing your SDK like it&rsquo;s the IKEA of dependencies. Simplicity wins the day.</p>
<h3 id="11-using-deprecated-libraries">1.1 Using Deprecated Libraries<a hidden class="anchor" aria-hidden="true" href="#11-using-deprecated-libraries">#</a></h3>
<p><strong>Why it&rsquo;s a bad idea? (as if them being a 3rd party is not bad enough)</strong>
Ah, deprecated libraries - like old, broken toys that should&rsquo;ve been thrown out years ago, but somehow you just can&rsquo;t let go. They no longer receive updates, bug fixes, or any kind of love. In fact, they bring along security vulnerabilities and compatibility issues like unwanted party crashers. If your SDK relies on them, congratulations: you&rsquo;ve just created a ticking time bomb for your users&rsquo; apps.</p>
<p><strong>What to do instead:</strong>
Keep up with the times. Refactor your SDK and ditch deprecated libraries before they sink the ship. Continuously monitor the libraries you&rsquo;re using (yes, that means some extra work) and update them before they&rsquo;re completely irrelevant - or worse, break something critical. Your users will thank you for not making them fight with zombie dependencies.</p>
<p><strong>Example</strong>: &ldquo;AsyncTask is My Best Friend&rdquo;</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Sdk</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">fun</span> <span class="nf">fetchDataInBackground</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Who cares if AsyncTask is deprecated? It&#39;s a classic!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">object</span> <span class="err">: </span><span class="nc">AsyncTask</span><span class="p">&lt;</span><span class="n">Void</span><span class="p">,</span> <span class="n">Void</span><span class="p">,</span> <span class="n">String</span><span class="p">&gt;()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">override</span> <span class="k">fun</span> <span class="nf">doInBackground</span><span class="p">(</span><span class="k">vararg</span> <span class="n">params</span><span class="p">:</span> <span class="n">Void</span><span class="p">?):</span> <span class="n">String</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// Simulating a network call
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">return</span> <span class="s2">&#34;Data fetched from background&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">override</span> <span class="k">fun</span> <span class="nf">onPostExecute</span><span class="p">(</span><span class="n">result</span><span class="p">:</span> <span class="n">String</span><span class="p">?)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// Handle result on the main thread
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}.</span><span class="n">execute</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Because who cares about Kotlin coroutines when we can use trusty old <strong>AsyncTask</strong> that Google has been telling us to avoid for years? Let&rsquo;s keep that 2012 vibe going strong. (And yes, I first hand found someone use it in 2024)</p>
<p><strong>Good Practice:</strong> &ldquo;Welcome to the 2020s - We Have Coroutines Now&rdquo;</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Sdk</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">fun</span> <span class="nf">fetchDataInBackground</span><span class="p">(</span><span class="n">callback</span><span class="p">:</span> <span class="p">(</span><span class="n">Result</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="o">-&gt;</span> <span class="n">Unit</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nc">GlobalScope</span><span class="p">.</span><span class="n">launch</span><span class="p">(</span><span class="nc">Dispatchers</span><span class="p">.</span><span class="n">IO</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">val</span> <span class="py">data</span> <span class="p">=</span> <span class="s2">&#34;Fetched data&#34;</span>
</span></span><span class="line"><span class="cl">                <span class="n">withContext</span><span class="p">(</span><span class="nc">Dispatchers</span><span class="p">.</span><span class="n">Main</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">callback</span><span class="p">(</span><span class="nc">Result</span><span class="p">.</span><span class="n">success</span><span class="p">(</span><span class="k">data</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">e</span><span class="p">:</span> <span class="n">Exception</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">withContext</span><span class="p">(</span><span class="nc">Dispatchers</span><span class="p">.</span><span class="n">Main</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">callback</span><span class="p">(</span><span class="nc">Result</span><span class="p">.</span><span class="n">failure</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Ah, <strong>Kotlin Coroutines</strong>, the cool, modern way to handle background tasks without dragging apps back to the dark ages. The best part? They don&rsquo;t trigger ANRs and actually make you look like you know what you&rsquo;re doing.
I&rsquo;m not ranting about coroutines. I&rsquo;m talking about those libraries buried six feet under in the graveyard of GitHub, last updated in 2019. Found some old but &ldquo;reliable&rdquo; library that&rsquo;s no longer maintained? Great, now definitely don&rsquo;t use its sketchy forks in an SDK you&rsquo;re shipping for poor developers to suffer through. Always remember: if the original library was abandoned, there&rsquo;s probably a good reason for it. Do everyone a favor and find a modern replacement instead.</p>
<h3 id="2-using-singletons-and-global-state-management">2. Using Singletons and Global State Management<a hidden class="anchor" aria-hidden="true" href="#2-using-singletons-and-global-state-management">#</a></h3>
<p><strong>Why It&rsquo;s a Bad Idea:</strong>
Ah yes, singletons - easy to set up, but a nightmare to live with when combined with mutable global state. They introduce unpredictable behavior, especially in multi-threaded environments, leading to race conditions, inconsistent states, and debugging nightmares. Need more than one instance of your SDK in the same app? Good luck with that. Worse, singletons often cause memory leaks by holding references to contexts or activities. They also hide dependencies, making code harder to test, maintain, and extend. Simply put, global state is a global headache.</p>
<p><strong>What to Do Instead:</strong>
Use dependency injection or factory patterns to create and manage your SDK instances. This gives the client app control over the scope and lifecycle of your SDK components, ensuring predictable behavior. Avoid mutable global state - keep state context-aware and scoped to instances. If you need shared functionality, consider context-safe singletons with immutable state or thread-safe designs. And always design your SDK to support multiple instances where applicable. Responsible scoping leads to cleaner code and fewer headaches.</p>
<p><strong>Example</strong>: &ldquo;Global State, Global Headache&rdquo;</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="line"><span class="cl"><span class="k">object</span> <span class="nc">SdkSingleton</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">var</span> <span class="py">globalAdState</span><span class="p">:</span> <span class="n">String</span> <span class="p">=</span> <span class="s2">&#34;No ad loaded yet&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">fun</span> <span class="nf">loadAd</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Modify global state at will!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">globalAdState</span> <span class="p">=</span> <span class="s2">&#34;Ad loaded!&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>Good Practice:</strong> &ldquo;Let&rsquo;s Scope This Like Adults&rdquo;</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Sdk</span><span class="p">(</span><span class="k">private</span> <span class="k">var</span> <span class="py">adState</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">fun</span> <span class="nf">loadAd</span><span class="p">():</span> <span class="n">Sdk</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Create a new instance with updated state
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">Sdk</span><span class="p">(</span><span class="s2">&#34;Ad loaded!&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Create new instances without messing with global state
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="py">sdkInstance</span> <span class="p">=</span> <span class="n">Sdk</span><span class="p">(</span><span class="s2">&#34;No ad loaded&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="py">newSdkInstance</span> <span class="p">=</span> <span class="n">sdkInstance</span><span class="p">.</span><span class="n">loadAd</span><span class="p">()</span>
</span></span></code></pre></div><p>Keep your global state to yourself, thank you. Scoping state to instances like a responsible developer means fewer headaches and less chaos.</p>
<h3 id="3-poor-documentation">3. Poor Documentation<a hidden class="anchor" aria-hidden="true" href="#3-poor-documentation">#</a></h3>
<p><strong>Why it&rsquo;s a bad idea?</strong>
So, you&rsquo;ve built an amazing SDK, but forgot to tell anyone how to actually use it. Now developers are banging their heads against the wall trying to figure out what your methods do. Misuse, bugs, and frustrated support emails follow. But hey, it&rsquo;s their fault for not reading your mind, right?</p>
<p><strong>What to do instead:</strong>
Write documentation like you&rsquo;re being graded on it. Clear, concise, and, most importantly, up-to-date. Include everything developers need: installation instructions, detailed API references, code examples, common use cases, and troubleshooting guides. And remember, just like your SDK, your docs should evolve. Developers don&rsquo;t have time for guesswork; help them out!</p>
<p><strong>Example</strong>: &ldquo;Good Luck, You&rsquo;ll Need It&rdquo;</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Sdk</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">fun</span> <span class="nf">doSomethingSuperImportant</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// But I won&#39;t tell you how or why
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>Good Practice:</strong> &ldquo;Let&rsquo;s Be Nice - Write Documentation&rdquo;</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Performs an important task that retrieves user data.
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param userId ID of the user to fetch data for.
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return User data in a Result wrapper.
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Sdk</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">fun</span> <span class="nf">fetchUserData</span><span class="p">(</span><span class="n">userId</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="n">callback</span><span class="p">:</span> <span class="p">(</span><span class="n">Result</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="o">-&gt;</span> <span class="n">Unit</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Retrieves user data and passes it to the callback
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">callback</span><span class="p">(</span><span class="nc">Result</span><span class="p">.</span><span class="n">success</span><span class="p">(</span><span class="s2">&#34;User data for </span><span class="si">$userId</span><span class="s2">&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Imagine the joy on a developer&rsquo;s face when they actually understand how your SDK works! Clear documentation is like a ray of sunshine on a cloudy day.</p>
<h3 id="4-bad-communication-ofchanges">4. Bad Communication of Changes<a hidden class="anchor" aria-hidden="true" href="#4-bad-communication-ofchanges">#</a></h3>
<p><strong>Why it&rsquo;s a bad idea?</strong>
Making breaking changes without telling anyone is the ultimate plot twist. You&rsquo;ll leave developers scratching their heads when their app mysteriously starts crashing after your latest update. And when features disappear or behaviors change with no explanation? Well, you&rsquo;ve just created a new level of frustration. Bonus points if the developer only finds out after deploying their app to production! </p>
<p><strong>What to do instead:</strong>
Communicate like an adult. Use proper versioning (ever heard of semantic versioning? It&rsquo;s your friend). Maintain a changelog that&rsquo;s actually useful, marking breaking changes clearly, and providing migration guides. Offering beta releases to let developers adapt before the official update drops? Now that&rsquo;s next-level professional.</p>
<h3 id="5-heavy-loading-and-big-size-of-theaar">5. Heavy-loading and Big Size of the AAR<a hidden class="anchor" aria-hidden="true" href="#5-heavy-loading-and-big-size-of-theaar">#</a></h3>
<p><strong>Why it&rsquo;s a bad idea?</strong>
Your SDK should be lean and mean, but instead, it&rsquo;s bloated like a post-buffet nap. A large SDK increases app size, leading to longer build times, sluggish performance, and higher memory usage. You&rsquo;ve just transformed that sleek app into a lumbering dinosaur. End users now get to enjoy painfully slow downloads, and developers get to spend their days trying to optimize around your behemoth of an SDK.</p>
<p><strong>What to do instead:</strong>
Trim the fat. Optimize your SDK by stripping unused code and resources. Use ProGuard or R8 to shrink and obfuscate code, and modularize your SDK so developers can choose only the parts they need. The goal? A lightweight core with optional feature modules. Because no one likes dragging around unnecessary baggage.</p>
<p><strong>Example</strong>: &ldquo;Let&rsquo;s Make This AAR the Size of a Small Planet&rdquo;</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="line"><span class="cl"><span class="c1">// Packed with unnecessary resources like high-res images and massive JSON files
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">res</span><span class="p">/</span><span class="n">drawable</span><span class="p">/</span><span class="n">hd_background</span><span class="p">.</span><span class="n">png</span>
</span></span><span class="line"><span class="cl"><span class="n">res</span><span class="p">/</span><span class="n">animations</span><span class="p">/</span><span class="n">full_length_animation</span><span class="p">.</span><span class="n">json</span>
</span></span><span class="line"><span class="cl"><span class="n">asset</span><span class="p">/</span><span class="n">mother_nature</span><span class="p">.</span><span class="n">so</span>
</span></span></code></pre></div><p>Good Practice: &ldquo;Let&rsquo;s Not Make Developers Hate Us&rdquo;</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="line"><span class="cl"><span class="c1">// Use ProGuard to slim down the AAR 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">android</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">buildTypes</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">release</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">minifyEnabled</span> <span class="k">true</span>
</span></span><span class="line"><span class="cl">            <span class="n">proguardFiles</span> <span class="n">getDefaultProguardFile</span><span class="p">(</span><span class="err">&#39;</span><span class="n">proguard</span><span class="p">-</span><span class="n">android</span><span class="p">-</span><span class="n">optimize</span><span class="p">.</span><span class="n">txt</span><span class="err">&#39;</span><span class="p">),</span> <span class="err">&#39;</span><span class="n">proguard</span><span class="p">-</span><span class="n">rules</span><span class="p">.</span><span class="n">pro</span><span class="err">&#39;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Split into modules so developers can choose what they actually need
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">implementation</span><span class="p">(</span><span class="s2">&#34;com.example.sdk:core:1.0.0&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">implementation</span><span class="p">(</span><span class="s2">&#34;com.example.sdk:ad-module:1.0.0&#34;</span><span class="p">)</span>
</span></span></code></pre></div><h2 id="part-2-an-idealapproach">Part 2: An Ideal approach<a hidden class="anchor" aria-hidden="true" href="#part-2-an-idealapproach">#</a></h2>
<h3 id="1-sdks-are-modules-indisguise">1. SDKs Are Modules in Disguise<a hidden class="anchor" aria-hidden="true" href="#1-sdks-are-modules-indisguise">#</a></h3>
<p>The process of developing an SDK closely resembles that of designing a module in a modular architecture, and adhering to <strong>clean architecture principles</strong> isn&rsquo;t just &ldquo;nice to have&rdquo; - it&rsquo;s essential. An SDK must behave like a guest in someone else&rsquo;s app, blending seamlessly without imposing on the host app&rsquo;s architecture. Let&rsquo;s break this down technically:</p>
<p><strong>1. Decoupling Concerns:</strong></p>
<ul>
<li>Clean architecture separates <strong>business logic</strong> (what the SDK does) from <strong>implementation details</strong> (how it does it). For example, the SDK should expose its core functionality via interfaces or abstract classes, while internal implementations remain private and modularized.</li>
<li>This ensures the SDK is flexible and doesn&rsquo;t directly tie its implementation to specific frameworks or third-party libraries.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="line"><span class="cl"><span class="k">interface</span> <span class="nc">AdLoader</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">fun</span> <span class="nf">loadAd</span><span class="p">(</span><span class="n">callback</span><span class="p">:</span> <span class="p">(</span><span class="n">Result</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="o">-&gt;</span> <span class="n">Unit</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">AdLoaderImpl</span><span class="p">(</span><span class="k">private</span> <span class="k">val</span> <span class="py">networkClient</span><span class="p">:</span> <span class="n">NetworkClient</span><span class="p">)</span> <span class="p">:</span> <span class="n">AdLoader</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">override</span> <span class="k">fun</span> <span class="nf">loadAd</span><span class="p">(</span><span class="n">callback</span><span class="p">:</span> <span class="p">(</span><span class="n">Result</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="o">-&gt;</span> <span class="n">Unit</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">networkClient</span><span class="p">.</span><span class="n">fetchAd</span> <span class="p">{</span> <span class="n">result</span> <span class="o">-&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="n">callback</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Here, <code>AdLoader</code> abstracts the business logic of loading ads, while <code>AdLoaderImpl</code> provides the implementation. The app integrating the SDK only interacts with the interface, keeping things modular and easy to test.</p>
<p><strong>2.  Testability:</strong></p>
<ul>
<li>Clean architecture ensures your SDK&rsquo;s core logic is independent of Android-specific APIs, making it easier to test. For instance, avoid tying core logic to <code>Activity</code>, <code>Context</code>, or <code>ViewModel</code> classes.</li>
<li>Instead, inject platform-dependent dependencies where needed, keeping the core business logic free from platform concerns.</li>
</ul>
<p><strong>3. Scalability:</strong></p>
<ul>
<li>Modular SDKs are easier to maintain and scale. If you decide to add a new feature (e.g., analytics integration), you can do so without overhauling the existing code. Separate the analytics feature into a module, and expose it only to apps that choose to include it.</li>
</ul>
<h3 id="how-to-apply-clean-architecture-tosdks">How to Apply Clean Architecture to SDKs<a hidden class="anchor" aria-hidden="true" href="#how-to-apply-clean-architecture-tosdks">#</a></h3>
<p><strong>1. Domain Layer:</strong> Handles the business rules and logic of your SDK. Expose only what&rsquo;s necessary through interfaces and keep this layer entirely independent of third-party libraries or platform code.</p>
<p><strong>2. Data Layer:</strong> Manages data sources (e.g., network or local storage). Use repository patterns to abstract data operations.</p>
<p><strong>3. Interface Layer (Optional):</strong> If your SDK includes UI, provide it as an optional package, separate from the core SDK logic. Use Compose or Views but allow developers to customize it or bypass it entirely.</p>
<p><strong>4. Dependency Injection:</strong> Design your SDK to work with DI frameworks like Dagger, Koin, or Hilt, or provide a way to inject dependencies manually. This gives integrators full control over lifecycle and scoping.</p>
<p><strong>Key Takeaway:</strong>
Clean architecture makes your SDK predictable, maintainable, and easy to integrate. Developers can trust that it will not clash with their app&rsquo;s architecture or create unwanted dependencies.</p>
<p>And I might not be the best person for teaching clean architecture. There are more than enough resources out there that you can learn from. The &ldquo;Clean Architecture: A Craftsman&rsquo;s Guide to Software Structure and Design&rdquo; by uncle bob is the perfect resource.</p>
<h3 id="swallow-the-hard-pill-of-library-implementation">Swallow the Hard Pill of Library Implementation<a hidden class="anchor" aria-hidden="true" href="#swallow-the-hard-pill-of-library-implementation">#</a></h3>
<p>SDK development requires a different mindset compared to app development, particularly when it comes to handling dependencies. Relying on third-party libraries in your SDK can lead to <a href="https://en.wikipedia.org/wiki/Dependency_hell">dependency hell</a> for developers integrating it into their apps. Here&rsquo;s a deeper dive into why and how to handle this challenge:</p>
<h4 id="why-overusing-third-party-libraries-is-problematic">Why Overusing Third-Party Libraries is Problematic<a hidden class="anchor" aria-hidden="true" href="#why-overusing-third-party-libraries-is-problematic">#</a></h4>
<p><strong>1. Version Conflicts:</strong> Apps integrating your SDK may already use the same libraries (e.g., Retrofit, OkHttp, Glide) but with different versions. If your SDK forces its version of these libraries, it can lead to dependency clashes that break the app. For example The host app uses Retrofit 2.9.0, but your SDK is built with Retrofit 2.5.0. The app fails to compile because Gradle doesn&rsquo;t know which version to use. Even if it compiles, runtime crashes could occur due to API differences.</p>
<p><strong>2. Increased APK Size:</strong> Every third-party library you include adds weight to the SDK. For instance, Glide adds several MBs of resources and code, which might not even be used if the app already has its own image-loading library, bloating the integrator&rsquo;s app.</p>
<p><strong>3. Licensing Issues:</strong> Not all libraries are compatible with commercial or open-source SDKs. Using a library with a restrictive license (e.g., GPL) can expose your SDK and its users to legal risks. Just because a project or developer hasn&rsquo;t sued you yet, doesn&rsquo;t mean what you&rsquo;re doing is legal.</p>
<h4 id="how-to-avoid-thesepitfalls">How to Avoid These Pitfalls<a hidden class="anchor" aria-hidden="true" href="#how-to-avoid-thesepitfalls">#</a></h4>
<p><strong>1. Implement Features Yourself:</strong> Yeah yeah &ldquo;Don&rsquo;t reinvent the wheel&rdquo; and all, but we have the above problems to address, rememeber? Instead of relying on libraries for common tasks, consider implementing lightweight, custom solutions tailored to your SDK&rsquo;s needs.</p>
<p><strong>Example</strong>: For networking, instead of using Retrofit:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="line"><span class="cl"><span class="k">fun</span> <span class="nf">fetchAd</span><span class="p">(</span><span class="n">callback</span><span class="p">:</span> <span class="p">(</span><span class="n">Result</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="o">-&gt;</span> <span class="n">Unit</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">val</span> <span class="py">url</span> <span class="p">=</span> <span class="n">URL</span><span class="p">(</span><span class="s2">&#34;https://api.example.com/ads&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">val</span> <span class="py">connection</span> <span class="p">=</span> <span class="n">url</span><span class="p">.</span><span class="n">openConnection</span><span class="p">()</span> <span class="k">as</span> <span class="n">HttpURLConnection</span>
</span></span><span class="line"><span class="cl">    <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">val</span> <span class="py">data</span> <span class="p">=</span> <span class="n">connection</span><span class="p">.</span><span class="n">inputStream</span><span class="p">.</span><span class="n">bufferedReader</span><span class="p">().</span><span class="n">readText</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="n">callback</span><span class="p">(</span><span class="nc">Result</span><span class="p">.</span><span class="n">success</span><span class="p">(</span><span class="k">data</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">e</span><span class="p">:</span> <span class="n">Exception</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">callback</span><span class="p">(</span><span class="nc">Result</span><span class="p">.</span><span class="n">failure</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">connection</span><span class="p">.</span><span class="n">disconnect</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>This implementation avoids dragging in a large library and keeps your SDK lightweight.</p>
<p><strong>2. Isolate Dependencies:</strong> If a library is <a href="https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it">unavoidable</a>, wrap it in an abstraction layer so the host app doesn&rsquo;t interact with it directly. This also makes it easier to replace the library in the future without breaking the SDK&rsquo;s API.</p>
<p><strong>Example:</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="line"><span class="cl"><span class="k">interface</span> <span class="nc">ImageLoader</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">fun</span> <span class="nf">loadImage</span><span class="p">(</span><span class="n">url</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="n">imageView</span><span class="p">:</span> <span class="n">ImageView</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">GlideImageLoader</span> <span class="p">:</span> <span class="n">ImageLoader</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">override</span> <span class="k">fun</span> <span class="nf">loadImage</span><span class="p">(</span><span class="n">url</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="n">imageView</span><span class="p">:</span> <span class="n">ImageView</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nc">Glide</span><span class="p">.</span><span class="n">with</span><span class="p">(</span><span class="n">imageView</span><span class="p">.</span><span class="n">context</span><span class="p">).</span><span class="n">load</span><span class="p">(</span><span class="n">url</span><span class="p">).</span><span class="n">into</span><span class="p">(</span><span class="n">imageView</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Again, do this as a last resort. It&rsquo;s always better to have your own implementation of essential libraries for networking, asynchronous operations, etc.</p>
<p><strong>3. Make Dependencies Optional:</strong> Use Gradle&rsquo;s optional dependencies to allow developers to exclude libraries they don&rsquo;t need.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scss" data-lang="scss"><span class="line"><span class="cl"><span class="nt">implementation</span><span class="o">(</span><span class="s2">&#34;com.example.sdk:core:1.0.0&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="nt">implementation</span><span class="o">(</span><span class="s2">&#34;com.example.sdk:ui:1.0.0&#34;</span><span class="o">)</span> <span class="o">//</span> <span class="nt">Include</span> <span class="nt">only</span> <span class="nt">if</span> <span class="nt">UI</span> <span class="nt">is</span> <span class="nt">needed</span>
</span></span></code></pre></div><p>Does your SDK provides more than 1 functionality? Then chances are you&rsquo;re gonna need a package per functionality. A very perfect and relatable example is how <a href="https://firebase.google.com/docs/android/android-play-services">Firebase</a> has designed its dependencies with its Android SDK.</p>
<p><strong>Key Takeaway:</strong> By implementing features in-house and isolating dependencies, you ensure your SDK is lightweight, conflict-free, and safe to integrate. Yes, it&rsquo;s more work upfront, but it&rsquo;s worth it to avoid becoming the SDK developers hate using.</p>
<h2 id="conclusion">Conclusion:<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h2>
<p>Developing an SDK is not just about building functionality; it&rsquo;s about crafting a developer-friendly experience that integrates seamlessly into diverse apps without causing headaches. As this article has outlined, creating an effective SDK requires careful consideration of architecture, dependencies, UI integration, and communication with developers. It&rsquo;s a balancing act between providing robust functionality and maintaining flexibility, scalability, and simplicity.</p>
<p>By treating your SDK as a modular system adhering to clean architecture principles, you ensure maintainability, testability, and long-term compatibility. Writing your own libraries, while a harder path, avoids the pitfalls of third-party dependency conflicts, licensing issues, and bloated SDK sizes, making your SDK a lightweight, reliable addition to any app.</p>
<p>Ultimately, an SDK is a tool meant to empower developers, not frustrate them. Keep your design unobtrusive, your APIs intuitive, and your documentation thorough. If you approach SDK development with the same care you would a mission-critical backend service, you&rsquo;ll create a product that developers trust and love to use.</p>
<p>SDK development may be challenging, but by applying these principles, you can turn the good, the bad, and the ugly into a toolkit that stands out in the best way possible. Remember, when developers integrate your SDK, they&rsquo;re placing their trust in you - don&rsquo;t let them down.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://arjmandi.de/tags/android/">Android</a></li>
      <li><a href="https://arjmandi.de/tags/kotlin/">Kotlin</a></li>
      <li><a href="https://arjmandi.de/tags/sdk/">Sdk</a></li>
      <li><a href="https://arjmandi.de/tags/sdk-development/">Sdk-Development</a></li>
      <li><a href="https://arjmandi.de/tags/clean-architecture/">Clean-Architecture</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://arjmandi.de/blog/core-module-is-bad/">
    <span class="title">« Prev</span>
    <br>
    <span>Android Koans: core modules.</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
