[{"content":" \u0026ldquo;The Koans\u0026rdquo; series consists of excerpts from my conversations with other engineers whom I turn to when I have questions. I usually come up with a question, ask them, and then try to understand their response. I then add some of my own insights to ensure my understanding (and potentially help others understand as well) before publishing them on this blog.\nPretext Today, I started a project from scratch and added a core module. I then asked myself, “It might be useful to place this and that into the core module for reuse later—but what if I end up injecting it into every module and submodule? Wouldn’t that violate loose coupling and the Single Responsibility Principle?” Seeking clarity, I turned to Mohsen for guidance. That conversation led to a moment of enlightment.\nWhat is a core module? A :core typically refers to a library module that contains shared code or utilities used across multiple modules in a project (e.g., :core, :common, :base, etc.). These modules are often created to avoid duplication and promote reuse of code such as:\nExtensions functions Utility classes Network/data models Constants Helper methods How should I inject them in my other modules? Short answer: You shouldn\u0026rsquo;t. You should try to get rid of this module.\nWhy? Introducing a core module sets off a chain reaction (like tipping the first of three dominos) each leading to increasing architectural degradation.\n1. Ambiguity of \u0026ldquo;Core\u0026rdquo; The term core, or its equivalent, is ambiguous and often confusing. There is no clear consensus among developers about what should reside within a core module. Should it contain core business logic? Should it be limited to base classes and foundational abstraction layers? Should it even include any core functionality at all? Or should it be a completely independent module containing only tools and utility classes? This lack of clarity inevitably leads to reduced readability and long-term confusion and also makes the core module\n2. Prone to being misuesd At some point, someone will inevitably start adding code to the core module that was never intended to be placed there. Due to this ambiguity, developers may treat the core module as a dumping ground for code they’re unsure where to place. As a result, the core module (originally meant to promote clean, low-footprint architecture) can devolve into a verbose, catch-all module containing everything from network handlers to formatters and mapper utilities.\n3. Inevitablity of a refactor Eventually, someone will need to address the problems introduced by the core module. If they want to avoid side effects—such as having to include the entire core module just to use a simple logger, or multiple developers simultaneously modifying it because they each decide their logic belongs there—then a refactor becomes inevitable. The outcome? The monolithic core module gets broken down into smaller, focused modules like network, local_storage, logger, and so on. So why not distribute these responsibilities from the start and avoid unnecessary overhead later?\n4. An orphan module (Lack of ownership) When a core module becomes a dumping ground for everything that might be useful somewhere else (utility functions, constants, extensions, logging helpers, DI setup, network models, etc.) no one feels responsible for maintaining it. It becomes a \u0026ldquo;shared\u0026rdquo; place where anyone can add anything without clear rules or ownership. Without ownership, bugs go unfixed, outdated code piles up, and new developers don’t know where to look. Developers don’t know what belongs in :core, and Because everyone uses :core, no one wants to touch it for fear of breaking everything.\nVerdict While the idea of a core module may seem like a smart way to centralize reusable components, in practice it often introduces more problems than it solves. Its vague purpose, tendency to attract unrelated code, and lack of clear ownership can lead to significant architectural decay over time. Rather than relying on a monolithic core, favor small, well-named, purpose-specific modules from the start. This approach not only promotes clean boundaries and single responsibility but also makes your codebase easier to navigate, test, and evolve. When in doubt, split it out.\nMantra \u0026ldquo;Core isn’t a junk drawer. Organize from day one.\u0026rdquo;\n","permalink":"https://arjmandi.de/blog/core-module-is-bad/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u0026ldquo;The Koans\u0026rdquo; series consists of excerpts from my conversations with other engineers whom I turn to when I have questions. I usually come up with a question, ask them, and then try to understand their response. I then add some of my own insights to ensure my understanding (and potentially help others understand as well) before publishing them on this blog.\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"pretext\"\u003ePretext\u003c/h2\u003e\n\u003cp\u003eToday, I started a project from scratch and added a core module. I then asked myself, “It might be useful to place this and that into the core module for reuse later—but what if I end up injecting it into every module and submodule? Wouldn’t that violate loose coupling and the Single Responsibility Principle?” Seeking clarity, I turned to \u003ca href=\"http://mbt925.github.io\"\u003eMohsen\u003c/a\u003e for guidance. That conversation led to a moment of enlightment.\u003c/p\u003e","title":"Android Koans: core modules."},{"content":"Some boring backstory intro A few years ago, a friend roped me into a \u0026ldquo;simple\u0026rdquo; side project to make some extra cash. The plan? Build a few apps, slap on some ads, and watch the money roll in. Easy, right? Well… not quite. We quickly found ourselves tangled in a mess of issues. Google AdMob gave us trouble, some ad networks were outright shady, and others offered rates so bad, it wasn\u0026rsquo;t even worth the effort. After one particularly frustrating day, it hit me: \u0026ldquo;Why not build a library to handle all these ad networks and decide which ads to show based on the best deal?\u0026rdquo; Little did I know, this concept already had a name - ad mediation. Since we had a few adnetworks to play with, the idea of creating our own SDK seemed like a no-brainer. To our surprise, the SDK became such a hit (in our scale) that it completely overshadowed the apps we were trying to monetize in the first place. Suddenly, the SDK was the star of the show, and our apps? Well, they took a back seat. That was the start of my SDK-building journey. Fast forward through a decade of working with SDKs - both my own and ones from big-name companies and niche B2B partners - and let\u0026rsquo;s just say, I\u0026rsquo;ve seen the good, the bad, and the downright ugly when it comes to SDKs. I think I qualify as a SDK expert.\nPart 1: How NOT to develop a SDK (At least targetting the Android platform)? 0. Developing the SDK with a Client-Side Application Mindset Why it\u0026rsquo;s a bad idea? Sure, building an SDK like it\u0026rsquo;s just another app sounds tempting. But remember, your SDK is going to live in other people\u0026rsquo;s apps, all with their own unique setups and preferences. Treating it like a client-side app leads to all kinds of fun issues, like tightly coupled architecture, a complete lack of flexibility, and some deliciously unintended side effects. Client apps come with all kinds of assumptions - about UI, lifecycle, and direct access to device resources - that your SDK has no business messing with. It\u0026rsquo;s like crashing someone else\u0026rsquo;s dinner party and rearranging all their furniture.\nI\u0026rsquo;m not saying you should disregard good practices for client-side apps. It\u0026rsquo;s equally important for them to have a good, maintainable architecture and remain flexible. However, client-side apps are generally more resilient to faults that would be unacceptable when developing an SDK. Ideally, there shouldn\u0026rsquo;t even be an option to create technical debt when building an SDK.\nWhat to do instead: Instead of treating your SDK like an app, think of it as a backend service that cannot be updated once live. Decouple your concerns, provide asynchronous operations, and for goodness\u0026rsquo; sake, be lightweight and unobtrusive. Your SDK should blend into the background, flexible enough to work across a variety of apps without needing to know how they handle their UI, threading, or device resources. Be the guest that\u0026rsquo;s never noticed - until they need you.\nExample: \u0026ldquo;I Control the UI Now, Mwahaha!\u0026rdquo;\nclass Sdk { fun showProgressDialog(context: Context) { // Let\u0026#39;s hijack the UI without asking! ProgressDialog(context).apply { setTitle(\u0026#34;Please wait...\u0026#34;) setMessage(\u0026#34;SDK is doing something super important!\u0026#34;) show() } } } Because who doesn\u0026rsquo;t want their UI randomly hijacked by some SDK? You\u0026rsquo;ve spent hours perfecting your app\u0026rsquo;s UX, but sure, let\u0026rsquo;s just throw in this uninvited ProgressDialog in the middle of everything. Thanks, SDK!\nGood Practice: \u0026ldquo;Wait, SDKs Shouldn\u0026rsquo;t Mess With UIs?\u0026rdquo;\nclass Sdk { fun performBackendOperation(callback: (Result\u0026lt;String\u0026gt;) -\u0026gt; Unit) { // Asynchronous backend logic without UI intervention callback(Result.success(\u0026#34;Operation Completed!\u0026#34;)) } } Look, mom, no UI! The SDK does what it\u0026rsquo;s supposed to: backend operations, leaving the app developer to decide how to show progress, if at all.\nWait, what if the UI is part of what our SDK is trying to offer?\nYou\u0026rsquo;re already going to ruin the experience of the poor developer trying to integrate your SDK into their app. You might think:\nBut the end user will have a good experience\nAnd while that might be true in some cases, it\u0026rsquo;s often unlikely for various reasons, including:\nLack of Flexibility for Developers: Predefined UI components limit developers\u0026rsquo; ability to customize the user interface, making it difficult to align the SDK\u0026rsquo;s UI with the app\u0026rsquo;s branding and design. Since the UI is fixed, integrators also lose the ability to embed custom analytics, making it harder to track user activity for marketing or product analysis. This leads to inconsistent user experiences and missed insights, negatively impacting the perception of both the app and the SDK. Resource Conflicts: Bundling UI components can cause resource naming collisions (e.g., IDs, styles, or themes) between the SDK and the host app, leading to unexpected crashes or visual inconsistencies. These issues can require significant debugging effort, reducing developers\u0026rsquo; trust in the SDK. Increased Maintenance Complexity: Including UI in the SDK requires ongoing maintenance to ensure compatibility with various Android versions, devices, and design guidelines. This increases the maintenance burden, and delays or unaddressed issues can frustrate developers and users, making the SDK less appealing. Larger SDK Size: Shipping UI components increases the overall size of the SDK, which contributes to larger app sizes. This can deter developers from adopting the SDK, and end-users may avoid downloading apps or uninstall them due to size concerns, indirectly affecting SDK adoption. (like yeah, let\u0026rsquo;s integrate \u0026ldquo;com.github.javad:awesome-animation:0.0.2\u0026rdquo; and add 5 more megabytes to poor developer\u0026rsquo;s app) Limited Reusability and Scalability: UI components shipped with the SDK are often not reusable or scalable across different projects. Developers working on apps with custom flows or designs may need to bypass or rewrite the SDK\u0026rsquo;s UI. Additionally, because the UI is fixed, integrators cannot track user activity within the SDK for custom marketing or product analytics purposes, reducing its value and making it appear rigid and developer-unfriendly. If you absolutely have to ship UI as part of your project, the best way to approach it is to make the UI optional and modular. Here\u0026rsquo;s how you can do it:\nSeparate UI and Core Logic: Create two distinct packages: one for the core functionality and one for the UI components. This allows developers to choose whether they want to use the provided UI or build their own while still leveraging the core logic of the SDK. Provide Clear Documentation: Offer detailed instructions for implementing the SDK with and without the built-in UI. Include code samples and guidelines for developers who want to customize or replace the default UI. Make the UI Customizable: If you include a UI package, ensure it is fully customizable. Allow developers to override styles, colors, fonts, and even layouts to match their app\u0026rsquo;s branding and design. Design for Integration: Ensure the UI components follow Android\u0026rsquo;s Material Design guidelines and can adapt seamlessly to different themes, orientations, and screen sizes. Use isolated namespaces to avoid resource conflicts. Support Analytics Hooks: Provide APIs or callbacks that allow developers to integrate their analytics and tracking solutions into the SDK\u0026rsquo;s UI. This ensures that they can still collect data and maintain insights into user behavior. Offer a \u0026ldquo;Headless Mode\u0026rdquo;: For advanced users, offer a \u0026ldquo;headless\u0026rdquo; mode that exposes only the core logic, enabling developers to integrate it into their own UI without relying on your SDK\u0026rsquo;s visuals. An ideal SDK with UI should have at least 2 importable modules, 1 for the core functionality, and one for UI.\n1. Using 3rd Party Libraries Inside Your SDK Why it\u0026rsquo;s a bad idea? Sure, nothing says \u0026ldquo;I\u0026rsquo;m in a hurry\u0026rdquo; like cramming in every shiny third-party library you can find. But here\u0026rsquo;s the catch: it comes with a whole list of issues. Ever dealt with version conflicts? Yeah, enjoy those. Licensing problems? Even better! Or how about making the host app developers manage complex dependency resolution because your SDK decided to use a different version of Retrofit, OkHttp, Glide, and Lottie than they do? Just imagine the joy when their app breaks, and they have to dig through Maven hell to figure out which library caused the explosion. You\u0026rsquo;re welcome!\nWhat to do instead: Minimize external dependencies like you\u0026rsquo;re on a code diet. Especially for core functionality. If you absolutely must drag in third-party libraries (and hey, I get it, they\u0026rsquo;re useful), isolate them. Or better yet, give the app developers the option to exclude or replace them. And please, document what libraries you\u0026rsquo;re using so it doesn\u0026rsquo;t feel like a game of \u0026ldquo;surprise dependency roulette.\u0026rdquo; It\u0026rsquo;s a party no one wants to attend.\nExample: \u0026ldquo;Let\u0026rsquo;s Bring the Whole Party! Retrofit, OkHttp, Glide, and Lottie!\u0026rdquo;\nclass Sdk { // Retrofit to fetch data private val retrofit = Retrofit.Builder() .baseUrl(\u0026#34;https://api.example.com/\u0026#34;) .build() // OkHttp for all the fancy HTTP interceptors private val client = OkHttpClient.Builder().build() // Glide to load images, of course fun loadImage(context: Context, imageUrl: String, imageView: ImageView) { Glide.with(context) .load(imageUrl) .into(imageView) } // And why not add Lottie animations for good measure? fun showLottieAnimation(context: Context, animationView: LottieAnimationView) { animationView.setAnimation(\u0026#34;cool_animation.json\u0026#34;) animationView.playAnimation() } } Because why just load ads when you can load the entire internet along with them? Let\u0026rsquo;s add Retrofit for fetching some unnecessary data, OkHttp for all those fancy interceptors, Glide to load the most important image in history, and hey, let\u0026rsquo;s slap a Lottie animation on it too. What could go wrong? 🤷‍♂️ I mean, who doesn\u0026rsquo;t love an SDK that bloats your app by 10MB with libraries it never even needed? Oh, and good luck dealing with version conflicts in your app! 😎 Good Practice: Just Keep It Simple, Stupid\nclass Sdk { // Avoid unnecessary dependencies fun performSimpleNetworkOperation(callback: (Result\u0026lt;String\u0026gt;) -\u0026gt; Unit) { // Use plain old URL and HttpURLConnection, or let the app manage HTTP libraries. callback(Result.success(\u0026#34;Fetched data\u0026#34;)) } // Let the app handle image loading and animations fun loadDataAndReturnUrl(callback: (String) -\u0026gt; Unit) { // Just return a URL and let the app handle loading the image or animation callback(\u0026#34;https://image.example.com\u0026#34;) } } Here\u0026rsquo;s an idea: let the developer decide if they want to use Retrofit, OkHttp, Glide, or Lottie. Stop packing your SDK like it\u0026rsquo;s the IKEA of dependencies. Simplicity wins the day.\n1.1 Using Deprecated Libraries Why it\u0026rsquo;s a bad idea? (as if them being a 3rd party is not bad enough) Ah, deprecated libraries - like old, broken toys that should\u0026rsquo;ve been thrown out years ago, but somehow you just can\u0026rsquo;t let go. They no longer receive updates, bug fixes, or any kind of love. In fact, they bring along security vulnerabilities and compatibility issues like unwanted party crashers. If your SDK relies on them, congratulations: you\u0026rsquo;ve just created a ticking time bomb for your users\u0026rsquo; apps.\nWhat to do instead: Keep up with the times. Refactor your SDK and ditch deprecated libraries before they sink the ship. Continuously monitor the libraries you\u0026rsquo;re using (yes, that means some extra work) and update them before they\u0026rsquo;re completely irrelevant - or worse, break something critical. Your users will thank you for not making them fight with zombie dependencies.\nExample: \u0026ldquo;AsyncTask is My Best Friend\u0026rdquo;\nclass Sdk { fun fetchDataInBackground() { // Who cares if AsyncTask is deprecated? It\u0026#39;s a classic! object : AsyncTask\u0026lt;Void, Void, String\u0026gt;() { override fun doInBackground(vararg params: Void?): String { // Simulating a network call return \u0026#34;Data fetched from background\u0026#34; } override fun onPostExecute(result: String?) { // Handle result on the main thread } }.execute() } } Because who cares about Kotlin coroutines when we can use trusty old AsyncTask that Google has been telling us to avoid for years? Let\u0026rsquo;s keep that 2012 vibe going strong. (And yes, I first hand found someone use it in 2024)\nGood Practice: \u0026ldquo;Welcome to the 2020s - We Have Coroutines Now\u0026rdquo;\nclass Sdk { fun fetchDataInBackground(callback: (Result\u0026lt;String\u0026gt;) -\u0026gt; Unit) { GlobalScope.launch(Dispatchers.IO) { try { val data = \u0026#34;Fetched data\u0026#34; withContext(Dispatchers.Main) { callback(Result.success(data)) } } catch (e: Exception) { withContext(Dispatchers.Main) { callback(Result.failure(e)) } } } } } Ah, Kotlin Coroutines, the cool, modern way to handle background tasks without dragging apps back to the dark ages. The best part? They don\u0026rsquo;t trigger ANRs and actually make you look like you know what you\u0026rsquo;re doing. I\u0026rsquo;m not ranting about coroutines. I\u0026rsquo;m talking about those libraries buried six feet under in the graveyard of GitHub, last updated in 2019. Found some old but \u0026ldquo;reliable\u0026rdquo; library that\u0026rsquo;s no longer maintained? Great, now definitely don\u0026rsquo;t use its sketchy forks in an SDK you\u0026rsquo;re shipping for poor developers to suffer through. Always remember: if the original library was abandoned, there\u0026rsquo;s probably a good reason for it. Do everyone a favor and find a modern replacement instead.\n2. Using Singletons and Global State Management Why It\u0026rsquo;s a Bad Idea: Ah yes, singletons - easy to set up, but a nightmare to live with when combined with mutable global state. They introduce unpredictable behavior, especially in multi-threaded environments, leading to race conditions, inconsistent states, and debugging nightmares. Need more than one instance of your SDK in the same app? Good luck with that. Worse, singletons often cause memory leaks by holding references to contexts or activities. They also hide dependencies, making code harder to test, maintain, and extend. Simply put, global state is a global headache.\nWhat to Do Instead: Use dependency injection or factory patterns to create and manage your SDK instances. This gives the client app control over the scope and lifecycle of your SDK components, ensuring predictable behavior. Avoid mutable global state - keep state context-aware and scoped to instances. If you need shared functionality, consider context-safe singletons with immutable state or thread-safe designs. And always design your SDK to support multiple instances where applicable. Responsible scoping leads to cleaner code and fewer headaches.\nExample: \u0026ldquo;Global State, Global Headache\u0026rdquo;\nobject SdkSingleton { var globalAdState: String = \u0026#34;No ad loaded yet\u0026#34; fun loadAd() { // Modify global state at will! globalAdState = \u0026#34;Ad loaded!\u0026#34; } } Good Practice: \u0026ldquo;Let\u0026rsquo;s Scope This Like Adults\u0026rdquo;\nclass Sdk(private var adState: String) { fun loadAd(): Sdk { // Create a new instance with updated state return Sdk(\u0026#34;Ad loaded!\u0026#34;) } } // Create new instances without messing with global state val sdkInstance = Sdk(\u0026#34;No ad loaded\u0026#34;) val newSdkInstance = sdkInstance.loadAd() Keep your global state to yourself, thank you. Scoping state to instances like a responsible developer means fewer headaches and less chaos.\n3. Poor Documentation Why it\u0026rsquo;s a bad idea? So, you\u0026rsquo;ve built an amazing SDK, but forgot to tell anyone how to actually use it. Now developers are banging their heads against the wall trying to figure out what your methods do. Misuse, bugs, and frustrated support emails follow. But hey, it\u0026rsquo;s their fault for not reading your mind, right?\nWhat to do instead: Write documentation like you\u0026rsquo;re being graded on it. Clear, concise, and, most importantly, up-to-date. Include everything developers need: installation instructions, detailed API references, code examples, common use cases, and troubleshooting guides. And remember, just like your SDK, your docs should evolve. Developers don\u0026rsquo;t have time for guesswork; help them out!\nExample: \u0026ldquo;Good Luck, You\u0026rsquo;ll Need It\u0026rdquo;\nclass Sdk { fun doSomethingSuperImportant() { // But I won\u0026#39;t tell you how or why } } Good Practice: \u0026ldquo;Let\u0026rsquo;s Be Nice - Write Documentation\u0026rdquo;\n/** * Performs an important task that retrieves user data. * * @param userId ID of the user to fetch data for. * @return User data in a Result wrapper. */ class Sdk { fun fetchUserData(userId: String, callback: (Result\u0026lt;String\u0026gt;) -\u0026gt; Unit) { // Retrieves user data and passes it to the callback callback(Result.success(\u0026#34;User data for $userId\u0026#34;)) } } Imagine the joy on a developer\u0026rsquo;s face when they actually understand how your SDK works! Clear documentation is like a ray of sunshine on a cloudy day.\n4. Bad Communication of Changes Why it\u0026rsquo;s a bad idea? Making breaking changes without telling anyone is the ultimate plot twist. You\u0026rsquo;ll leave developers scratching their heads when their app mysteriously starts crashing after your latest update. And when features disappear or behaviors change with no explanation? Well, you\u0026rsquo;ve just created a new level of frustration. Bonus points if the developer only finds out after deploying their app to production! What to do instead: Communicate like an adult. Use proper versioning (ever heard of semantic versioning? It\u0026rsquo;s your friend). Maintain a changelog that\u0026rsquo;s actually useful, marking breaking changes clearly, and providing migration guides. Offering beta releases to let developers adapt before the official update drops? Now that\u0026rsquo;s next-level professional.\n5. Heavy-loading and Big Size of the AAR Why it\u0026rsquo;s a bad idea? Your SDK should be lean and mean, but instead, it\u0026rsquo;s bloated like a post-buffet nap. A large SDK increases app size, leading to longer build times, sluggish performance, and higher memory usage. You\u0026rsquo;ve just transformed that sleek app into a lumbering dinosaur. End users now get to enjoy painfully slow downloads, and developers get to spend their days trying to optimize around your behemoth of an SDK.\nWhat to do instead: Trim the fat. Optimize your SDK by stripping unused code and resources. Use ProGuard or R8 to shrink and obfuscate code, and modularize your SDK so developers can choose only the parts they need. The goal? A lightweight core with optional feature modules. Because no one likes dragging around unnecessary baggage.\nExample: \u0026ldquo;Let\u0026rsquo;s Make This AAR the Size of a Small Planet\u0026rdquo;\n// Packed with unnecessary resources like high-res images and massive JSON files res/drawable/hd_background.png res/animations/full_length_animation.json asset/mother_nature.so Good Practice: \u0026ldquo;Let\u0026rsquo;s Not Make Developers Hate Us\u0026rdquo;\n// Use ProGuard to slim down the AAR android { buildTypes { release { minifyEnabled true proguardFiles getDefaultProguardFile(\u0026#39;proguard-android-optimize.txt\u0026#39;), \u0026#39;proguard-rules.pro\u0026#39; } } } // Split into modules so developers can choose what they actually need implementation(\u0026#34;com.example.sdk:core:1.0.0\u0026#34;) implementation(\u0026#34;com.example.sdk:ad-module:1.0.0\u0026#34;) Part 2: An Ideal approach 1. SDKs Are Modules in Disguise The process of developing an SDK closely resembles that of designing a module in a modular architecture, and adhering to clean architecture principles isn\u0026rsquo;t just \u0026ldquo;nice to have\u0026rdquo; - it\u0026rsquo;s essential. An SDK must behave like a guest in someone else\u0026rsquo;s app, blending seamlessly without imposing on the host app\u0026rsquo;s architecture. Let\u0026rsquo;s break this down technically:\n1. Decoupling Concerns:\nClean architecture separates business logic (what the SDK does) from implementation details (how it does it). For example, the SDK should expose its core functionality via interfaces or abstract classes, while internal implementations remain private and modularized. This ensures the SDK is flexible and doesn\u0026rsquo;t directly tie its implementation to specific frameworks or third-party libraries. interface AdLoader { fun loadAd(callback: (Result\u0026lt;String\u0026gt;) -\u0026gt; Unit) } class AdLoaderImpl(private val networkClient: NetworkClient) : AdLoader { override fun loadAd(callback: (Result\u0026lt;String\u0026gt;) -\u0026gt; Unit) { networkClient.fetchAd { result -\u0026gt; callback(result) } } } Here, AdLoader abstracts the business logic of loading ads, while AdLoaderImpl provides the implementation. The app integrating the SDK only interacts with the interface, keeping things modular and easy to test.\n2. Testability:\nClean architecture ensures your SDK\u0026rsquo;s core logic is independent of Android-specific APIs, making it easier to test. For instance, avoid tying core logic to Activity, Context, or ViewModel classes. Instead, inject platform-dependent dependencies where needed, keeping the core business logic free from platform concerns. 3. Scalability:\nModular SDKs are easier to maintain and scale. If you decide to add a new feature (e.g., analytics integration), you can do so without overhauling the existing code. Separate the analytics feature into a module, and expose it only to apps that choose to include it. How to Apply Clean Architecture to SDKs 1. Domain Layer: Handles the business rules and logic of your SDK. Expose only what\u0026rsquo;s necessary through interfaces and keep this layer entirely independent of third-party libraries or platform code.\n2. Data Layer: Manages data sources (e.g., network or local storage). Use repository patterns to abstract data operations.\n3. Interface Layer (Optional): If your SDK includes UI, provide it as an optional package, separate from the core SDK logic. Use Compose or Views but allow developers to customize it or bypass it entirely.\n4. Dependency Injection: Design your SDK to work with DI frameworks like Dagger, Koin, or Hilt, or provide a way to inject dependencies manually. This gives integrators full control over lifecycle and scoping.\nKey Takeaway: Clean architecture makes your SDK predictable, maintainable, and easy to integrate. Developers can trust that it will not clash with their app\u0026rsquo;s architecture or create unwanted dependencies.\nAnd I might not be the best person for teaching clean architecture. There are more than enough resources out there that you can learn from. The \u0026ldquo;Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design\u0026rdquo; by uncle bob is the perfect resource.\nSwallow the Hard Pill of Library Implementation SDK development requires a different mindset compared to app development, particularly when it comes to handling dependencies. Relying on third-party libraries in your SDK can lead to dependency hell for developers integrating it into their apps. Here\u0026rsquo;s a deeper dive into why and how to handle this challenge:\nWhy Overusing Third-Party Libraries is Problematic 1. Version Conflicts: Apps integrating your SDK may already use the same libraries (e.g., Retrofit, OkHttp, Glide) but with different versions. If your SDK forces its version of these libraries, it can lead to dependency clashes that break the app. For example The host app uses Retrofit 2.9.0, but your SDK is built with Retrofit 2.5.0. The app fails to compile because Gradle doesn\u0026rsquo;t know which version to use. Even if it compiles, runtime crashes could occur due to API differences.\n2. Increased APK Size: Every third-party library you include adds weight to the SDK. For instance, Glide adds several MBs of resources and code, which might not even be used if the app already has its own image-loading library, bloating the integrator\u0026rsquo;s app.\n3. Licensing Issues: Not all libraries are compatible with commercial or open-source SDKs. Using a library with a restrictive license (e.g., GPL) can expose your SDK and its users to legal risks. Just because a project or developer hasn\u0026rsquo;t sued you yet, doesn\u0026rsquo;t mean what you\u0026rsquo;re doing is legal.\nHow to Avoid These Pitfalls 1. Implement Features Yourself: Yeah yeah \u0026ldquo;Don\u0026rsquo;t reinvent the wheel\u0026rdquo; and all, but we have the above problems to address, rememeber? Instead of relying on libraries for common tasks, consider implementing lightweight, custom solutions tailored to your SDK\u0026rsquo;s needs.\nExample: For networking, instead of using Retrofit:\nfun fetchAd(callback: (Result\u0026lt;String\u0026gt;) -\u0026gt; Unit) { val url = URL(\u0026#34;https://api.example.com/ads\u0026#34;) val connection = url.openConnection() as HttpURLConnection try { val data = connection.inputStream.bufferedReader().readText() callback(Result.success(data)) } catch (e: Exception) { callback(Result.failure(e)) } finally { connection.disconnect() } } This implementation avoids dragging in a large library and keeps your SDK lightweight.\n2. Isolate Dependencies: If a library is unavoidable, wrap it in an abstraction layer so the host app doesn\u0026rsquo;t interact with it directly. This also makes it easier to replace the library in the future without breaking the SDK\u0026rsquo;s API.\nExample:\ninterface ImageLoader { fun loadImage(url: String, imageView: ImageView) } class GlideImageLoader : ImageLoader { override fun loadImage(url: String, imageView: ImageView) { Glide.with(imageView.context).load(url).into(imageView) } } Again, do this as a last resort. It\u0026rsquo;s always better to have your own implementation of essential libraries for networking, asynchronous operations, etc.\n3. Make Dependencies Optional: Use Gradle\u0026rsquo;s optional dependencies to allow developers to exclude libraries they don\u0026rsquo;t need.\nimplementation(\u0026#34;com.example.sdk:core:1.0.0\u0026#34;) implementation(\u0026#34;com.example.sdk:ui:1.0.0\u0026#34;) // Include only if UI is needed Does your SDK provides more than 1 functionality? Then chances are you\u0026rsquo;re gonna need a package per functionality. A very perfect and relatable example is how Firebase has designed its dependencies with its Android SDK.\nKey Takeaway: By implementing features in-house and isolating dependencies, you ensure your SDK is lightweight, conflict-free, and safe to integrate. Yes, it\u0026rsquo;s more work upfront, but it\u0026rsquo;s worth it to avoid becoming the SDK developers hate using.\nConclusion: Developing an SDK is not just about building functionality; it\u0026rsquo;s about crafting a developer-friendly experience that integrates seamlessly into diverse apps without causing headaches. As this article has outlined, creating an effective SDK requires careful consideration of architecture, dependencies, UI integration, and communication with developers. It\u0026rsquo;s a balancing act between providing robust functionality and maintaining flexibility, scalability, and simplicity.\nBy treating your SDK as a modular system adhering to clean architecture principles, you ensure maintainability, testability, and long-term compatibility. Writing your own libraries, while a harder path, avoids the pitfalls of third-party dependency conflicts, licensing issues, and bloated SDK sizes, making your SDK a lightweight, reliable addition to any app.\nUltimately, an SDK is a tool meant to empower developers, not frustrate them. Keep your design unobtrusive, your APIs intuitive, and your documentation thorough. If you approach SDK development with the same care you would a mission-critical backend service, you\u0026rsquo;ll create a product that developers trust and love to use.\nSDK development may be challenging, but by applying these principles, you can turn the good, the bad, and the ugly into a toolkit that stands out in the best way possible. Remember, when developers integrate your SDK, they\u0026rsquo;re placing their trust in you - don\u0026rsquo;t let them down.\n","permalink":"https://arjmandi.de/blog/sdk-dev-good-bad-ugly/","summary":"\u003ch2 id=\"some-boring-backstory-intro\"\u003eSome boring backstory intro\u003c/h2\u003e\n\u003cp\u003eA few years ago, a friend roped me into a \u0026ldquo;simple\u0026rdquo; side project to make some extra cash. The plan? Build a few apps, slap on some ads, and watch the money roll in. Easy, right? Well… not quite. We quickly found ourselves tangled in a mess of issues. Google AdMob gave us trouble, some ad networks were outright shady, and others offered rates so bad, it wasn\u0026rsquo;t even worth the effort. After one particularly frustrating day, it hit me: \u0026ldquo;Why not build a library to handle all these ad networks and decide which ads to show based on the best deal?\u0026rdquo; Little did I know, this concept already had a name - ad mediation. Since we had a few adnetworks to play with, the idea of creating our own SDK seemed like a no-brainer.\nTo our surprise, the SDK became such a hit (in our scale) that it completely overshadowed the apps we were trying to monetize in the first place. Suddenly, the SDK was the star of the show, and our apps? Well, they took a back seat.\nThat was the start of my SDK-building journey.\nFast forward through a decade of working with SDKs - both my own and ones from big-name companies and niche B2B partners - and let\u0026rsquo;s just say, I\u0026rsquo;ve seen the good, the bad, and the downright ugly when it comes to SDKs. I think I qualify as a SDK expert.\u003c/p\u003e","title":"SDK Development; The Good, The Bad, The Ugly"},{"content":"Hi, I’m Javad Arjmandi — an Android developer who enjoys crafting thoughtful, efficient, and modern mobile apps.\nI work primarily with Kotlin, Jetpack Compose, and Clean Architecture, and I like building things that are both elegant and maintainable. I care about clean code, developer experience, and solving real problems with the right tools — whether that’s Ktor on the backend or Coroutines on the UI thread.\nBut this site isn’t just about Android.\nI write about whatever I find interesting: technology trends, software design, politics, history, video games — anything that sparks curiosity or frustration. I believe good ideas are worth sharing, even if they don\u0026rsquo;t fit neatly into a portfolio.\nWhen I’m not deep in code or writing long blog posts, you’ll probably find me reading, gaming, or digging into some historical rabbit hole.\nThanks for stopping by.\n","permalink":"https://arjmandi.de/about/","summary":"\u003cp\u003eHi, I’m Javad Arjmandi — an Android developer who enjoys crafting thoughtful, efficient, and modern mobile apps.\u003cbr\u003e\nI work primarily with Kotlin, Jetpack Compose, and Clean Architecture, and I like building things that are both elegant and maintainable. I care about clean code, developer experience, and solving real problems with the right tools — whether that’s Ktor on the backend or Coroutines on the UI thread.\u003c/p\u003e\n\u003cp\u003eBut this site isn’t just about Android.\u003c/p\u003e","title":"About"}]